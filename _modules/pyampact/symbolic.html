

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyampact.symbolic &mdash; pyAMPACT 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="canonical" href="https://pyampact.github.io/_modules/pyampact/symbolic.html" />
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyAMPACT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../alignment.html">alignment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../alignmentUtils.html">alignmentUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataCompilation.html">dataCompilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance.html">performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../symbolic.html">symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../symbolicUtils.html">symbolicUtils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyAMPACT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyampact.symbolic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyampact.symbolic</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">symbolic</span>
<span class="sd">==============</span>


<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    Score</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">pyampact.symbolicUtils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">mido</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">librosa</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">.symbolicUtils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">music21</span> <span class="k">as</span> <span class="nn">m21</span>
<span class="n">m21</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;autoDownload&#39;</span><span class="p">,</span> <span class="s1">&#39;allow&#39;</span><span class="p">)</span>

<span class="c1"># utils</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">IndexSlice</span>

<span class="c1"># Comment for package build</span>

<span class="c1"># Uncomment for package build</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Score&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_assignM21Attributes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_partList&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_parts&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_import_other_spines&quot;</span><span class="p">,</span>
    <span class="s2">&quot;insertScoreDef&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xmlIDs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lyrics&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_m21Clefs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_clefs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dynamics&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_priority&quot;</span><span class="p">,</span>
    <span class="s2">&quot;keys&quot;</span><span class="p">,</span>
    <span class="s2">&quot;harm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;functions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chords&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cdata&quot;</span><span class="p">,</span>
    <span class="s2">&quot;getSpines&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dez&quot;</span><span class="p">,</span>
    <span class="s2">&quot;form&quot;</span><span class="p">,</span>
    <span class="s2">&quot;romanNumerals&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_m21ObjectsNoTies&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_measures&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_barlines&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_timeSignatures&quot;</span><span class="p">,</span>
    <span class="s2">&quot;durations&quot;</span><span class="p">,</span>
    <span class="s2">&quot;midi_ticks_durations&quot;</span><span class="p">,</span>
    <span class="s2">&quot;midiPitches&quot;</span><span class="p">,</span>
    <span class="s2">&quot;notes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;kernNotes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nmats&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pianoRoll&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sampled&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;jsonCDATA&quot;</span><span class="p">,</span>
    <span class="s2">&quot;insertAudioAnalysis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;show&quot;</span><span class="p">,</span>
    <span class="s2">&quot;toKern&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_meiStack&quot;</span><span class="p">,</span>
    <span class="s2">&quot;toMEI&quot;</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">convert_attribs_to_str</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
            <span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">element</span><span class="p">:</span>
        <span class="n">convert_attribs_to_str</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>


<div class="viewcode-block" id="Score">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score">[docs]</a>
<span class="k">class</span> <span class="nc">Score</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to import a score via music21 and expose pyAMPACT&#39;s analysis utilities.</span>

<span class="sd">    The analysis utilities are generally formatted as pandas dataframes. This </span>
<span class="sd">    class also ports over some matlab code to help with alignment of scores in </span>
<span class="sd">    symbolic notation and audio analysis of recordings of those scores. `Score` </span>
<span class="sd">    objects can insert analysis into an MEI file, and can export any type of </span>
<span class="sd">    file to a kern format, optionally also including analysis from a JSON file. </span>
<span class="sd">    Similarly, `Score` objects can serve clickable URLs of short excerpts of </span>
<span class="sd">    their associated score in symbolic notation. These links open in the Verovio </span>
<span class="sd">    Humdrum Viewer.</span>

<span class="sd">    :param score_path: A string representing the path to the score file.</span>
<span class="sd">    :return: A Score object.</span>

<span class="sd">    Example</span>
<span class="sd">    --------</span>
<span class="sd">    .. code-block:: python</span>

<span class="sd">        url_or_path = &#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;</span>
<span class="sd">        piece = Score(url_or_path)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score_path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">score_path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;https://github.com/&#39;</span><span class="p">):</span>
            <span class="n">score_path</span> <span class="o">=</span> <span class="s1">&#39;https://raw.githubusercontent.com/&#39;</span> <span class="o">+</span> \
                <span class="n">score_path</span><span class="p">[</span><span class="mi">19</span><span class="p">:]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/blob/&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">score_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileName</span> <span class="o">=</span> <span class="n">score_path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">=</span> <span class="n">score_path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span>
            <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">score_path</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">score_path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">==</span> <span class="s1">&#39;krn&#39;</span><span class="p">:</span>
            <span class="n">fd</span><span class="p">,</span> <span class="n">tmp_path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_assignM21Attributes</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_import_other_spines</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>
        <span class="c1"># file is not an online kern file (can be either or neither but not both)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assignM21Attributes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_import_other_spines</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">public</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prop</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="si">}{</span><span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">prop</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partList</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_assignM21Attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign music21 attributes to a given object.</span>

<span class="sd">        :param obj: A music21 object.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">imported_scores</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span>   <span class="c1"># parse humdrum files differently to extract their function, and harm spines if they have them</span>
                <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
                    <span class="n">path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;humdrum&#39;</span><span class="p">)</span>
            <span class="c1"># these files might be mei files and could lack elements music21 needs to be able to read them</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="s1">&#39;musicxml&#39;</span><span class="p">,</span> <span class="s1">&#39;mei&#39;</span><span class="p">,</span> <span class="s1">&#39;mxl&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">):</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
                        <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="n">remove_namespaces</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
                <span class="n">hasFunctions</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">_functions</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.//function&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_functions</span><span class="p">):</span>
                    <span class="n">hasFunctions</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># this is an mei file even if the fileExtension is .xml</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;mei&#39;</span><span class="p">):</span>
                    <span class="n">parseEdited</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                    <span class="c1"># this mei file doesn&#39;t have a scoreDef element, so construct one and add it to the score</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.//scoreDef&#39;</span><span class="p">):</span>
                        <span class="n">parseEdited</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">insertScoreDef</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

                    <span class="c1"># make sure all events are contained in measures</span>
                    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;section&#39;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;measure&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">parseEdited</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">measure</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;measure&#39;</span><span class="p">)</span>
                            <span class="n">measure</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;xml:id&#39;</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">))</span>
                            <span class="n">measure</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
                            <span class="n">section</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                            <span class="n">section</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">measure</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">parseEdited</span><span class="p">:</span>
                        <span class="n">mei_string</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;unicode&#39;</span><span class="p">)</span>
                        <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">subConverters</span><span class="o">.</span><span class="n">ConverterMEI</span><span class="p">(</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">parseData</span><span class="p">(</span><span class="n">mei_string</span><span class="p">)</span>
                        <span class="n">parseEdited</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">hasFunctions</span><span class="p">:</span>   <span class="c1"># not an mei file, but an xml file that had functions</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">m21</span><span class="o">.</span><span class="n">harmony</span><span class="o">.</span><span class="n">HarmonyException</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s1">&#39;There was an issue with the function texts so they were removed.&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">_function</span> <span class="ow">in</span> <span class="n">_functions</span><span class="p">:</span>
                            <span class="n">_function</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                        <span class="n">xml_string</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;unicode&#39;</span><span class="p">)</span>
                        <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
                            <span class="n">xml_string</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;MusicXML&#39;</span><span class="p">)</span>

            <span class="c1"># read file/string as volpiano or tinyNotation if applicable</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;txt&#39;</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">==</span> <span class="s1">&#39;txt&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">):</span>
                        <span class="n">text</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                            <span class="n">text</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;volpiano: &#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">volpiano_pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;volpiano&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;tinyNotation: &#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tinyNotation_pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;tinyNotation&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">_score</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Score</span><span class="p">()</span>
                    <span class="n">_score</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
                    <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">_score</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">==</span> <span class="s1">&#39;csv&#39;</span><span class="p">:</span>   <span class="c1"># read csv file as a pandas DataFrame with no header and no index</span>
                <span class="n">csv_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">csv_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;This csv file is not a 3-column Tony file so it can&#39;t be imported.&quot;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># assume it&#39;s a Tony file if it has 3 columns</span>
                    <span class="c1"># sometimes these files only have two columns instead of three</span>
                    <span class="n">csv_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">,</span> <span class="s1">&#39;AVG PITCH IN HZ&#39;</span><span class="p">,</span> <span class="s1">&#39;DURATION&#39;</span><span class="p">)[</span>
                        <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">csv_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
                    <span class="n">csv_df</span><span class="p">[</span><span class="s1">&#39;MIDI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">csv_df</span><span class="p">[</span><span class="s1">&#39;AVG PITCH IN HZ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">freq</span><span class="p">:</span> <span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_midi</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;Int16&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;tony_csv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">csv_df</span>
                    <span class="n">_parts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">csv_df</span><span class="p">[</span><span class="s1">&#39;MIDI&#39;</span><span class="p">])</span>
                    <span class="n">_parts</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Part-1&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_parts&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_parts</span>
                    <span class="n">dur</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">csv_df</span><span class="p">[</span><span class="s1">&#39;DURATION&#39;</span><span class="p">])</span>
                    <span class="n">dur</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Part-1&#39;</span><span class="p">]</span>
                    <span class="n">dur</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span>
                        <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dur</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;durations&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dur</span>
                    <span class="n">midiPitches</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">csv_df</span><span class="p">[</span><span class="s1">&#39;MIDI&#39;</span><span class="p">])</span>
                    <span class="n">midiPitches</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Part-1&#39;</span><span class="p">]</span>
                    <span class="n">midiPitches</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span>
                        <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">midiPitches</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;midiPitches&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">midiPitches</span>
                    <span class="n">measures</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">measures</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Part-1&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_measures&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span> <span class="o">=</span> <span class="n">measures</span>
                    <span class="n">xmlIDs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)</span>
                                          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">csv_df</span><span class="o">.</span><span class="n">index</span><span class="p">))])</span>
                    <span class="n">xmlIDs</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Part-1&#39;</span><span class="p">]</span>
                    <span class="n">xmlIDs</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span>
                        <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xmlIDs</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;xmlIDs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmlIDs</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Part-1&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_partList&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                    <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">imported_scores</span><span class="p">:</span>   <span class="c1"># check again to catch valid tree files</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="s1">&#39;midi&#39;</span><span class="p">):</span>
                <span class="n">midi_bytes</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
                <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">midi_bytes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">imported_scores</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s2">&quot;Title not found&quot;</span><span class="p">,</span>
                         <span class="s1">&#39;composer&#39;</span><span class="p">:</span> <span class="s2">&quot;Composer not found&quot;</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">title</span> <span class="ow">or</span> <span class="s1">&#39;Title not found&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;composer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">composer</span> <span class="ow">or</span> <span class="s1">&#39;Composer not found&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partStreams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="n">m21</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Part</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_partStreams</span><span class="p">):</span>
            <span class="n">flat</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">toRemove</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">flat</span> <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">flat</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">toRemove</span><span class="p">)</span>
            <span class="n">flat</span><span class="o">.</span><span class="n">makeMeasures</span><span class="p">(</span><span class="n">inPlace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">flat</span><span class="o">.</span><span class="n">makeAccidentals</span><span class="p">(</span><span class="n">inPlace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># you have to flatten again after calling makeMeasures</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flat</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">flat</span><span class="o">.</span><span class="n">partName</span> <span class="k">if</span> <span class="p">(</span>
                <span class="n">flat</span><span class="o">.</span><span class="n">partName</span> <span class="ow">and</span> <span class="n">flat</span><span class="o">.</span><span class="n">partName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">)</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;Part-</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_partList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of series of the note, rest, and chord objects in each part.</span>

<span class="sd">        :return: A list of pandas Series, each representing a part in the score.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_partList&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">kernStrands</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">isUnique</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">divisiStarts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">divisiEnds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">flat_part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="p">):</span>
                <span class="n">graces</span><span class="p">,</span> <span class="n">graceOffsets</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="n">notGraces</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">nrc</span> <span class="ow">in</span> <span class="n">flat_part</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">([</span><span class="s1">&#39;Note&#39;</span><span class="p">,</span> <span class="s1">&#39;Rest&#39;</span><span class="p">,</span> <span class="s1">&#39;Chord&#39;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">nrc</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">isGrace</span><span class="p">:</span>
                        <span class="n">graces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nrc</span><span class="p">)</span>
                        <span class="n">graceOffsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nrc</span><span class="o">.</span><span class="n">offset</span><span class="p">),</span> <span class="mi">5</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># get rid of really long rests TODO: make this get rid of rests longer than the prevailing measure</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">nrc</span><span class="o">.</span><span class="n">isRest</span> <span class="ow">and</span> <span class="n">nrc</span><span class="o">.</span><span class="n">quarterLength</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nrc</span><span class="o">.</span><span class="n">offset</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">notGraces</span><span class="p">:</span>
                            <span class="n">notGraces</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nrc</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">notGraces</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nrc</span><span class="p">]</span>

                <span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">notGraces</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ser</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>   <span class="c1"># no note, rest, or chord objects detected in this part</span>
                    <span class="n">ser</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ser</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="c1"># make each cell a row resulting in a df where each col is a separate synthetic voice</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
                <span class="c1"># swap elements in cols at this offset until all of them fill the space left before the next note in each col</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">ndx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                        <span class="c1"># calculate dur inside the loop to avoid having to swap its elements like we do for df</span>
                        <span class="n">dur</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">),</span> <span class="mi">5</span><span class="p">),</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">thisCol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">thisCol</span><span class="p">],</span> <span class="nb">float</span><span class="p">):</span>  <span class="c1"># ignore NaNs</span>
                                <span class="k">continue</span>
                            <span class="n">thisDur</span> <span class="o">=</span> <span class="n">dur</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">thisCol</span><span class="p">]</span>
                            <span class="n">thisNextNdx</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span> <span class="n">thisCol</span><span class="p">]</span><span class="o">.</span><span class="n">first_valid_index</span><span class="p">(</span>
                            <span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">highestTime</span>
                            <span class="n">thisPrevNdx</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">jj</span><span class="p">,</span>
                                                  <span class="n">thisCol</span><span class="p">]</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span> <span class="ow">or</span> <span class="mi">0</span>
                            <span class="k">if</span> <span class="n">thisPrevNdx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">thisPrevDur</span> <span class="o">=</span> <span class="n">dur</span><span class="p">[</span><span class="n">thisCol</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">thisPrevNdx</span><span class="p">]</span>
                                <span class="c1"># current note happens before previous note ended so swap for a NaN if there is one</span>
                                <span class="k">if</span> <span class="n">thisPrevNdx</span> <span class="o">+</span> <span class="n">thisPrevDur</span> <span class="o">-</span> <span class="n">ndx</span> <span class="o">&gt;</span> <span class="mf">.00003</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">otherCol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">thisCol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">otherCol</span><span class="p">],</span> <span class="nb">float</span><span class="p">):</span>
                                            <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">[</span><span class="n">thisCol</span><span class="p">,</span> <span class="n">otherCol</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">[</span>
                                                <span class="n">otherCol</span><span class="p">,</span> <span class="n">thisCol</span><span class="p">]]</span>
                                            <span class="k">break</span>
                            <span class="c1"># this nrc takes up the amount of time expected in this col so no need to swap</span>
                            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">thisNextNdx</span> <span class="o">-</span> <span class="n">ndx</span> <span class="o">-</span> <span class="n">thisDur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">.00003</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="c1"># look for an nrc in another col with the duration thisCol needs</span>
                            <span class="k">for</span> <span class="n">otherCol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">thisCol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                                <span class="c1"># once we get a nan there&#39;s no hope of finding a valid swap at this index</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">otherCol</span><span class="p">],</span> <span class="nb">float</span><span class="p">):</span>
                                    <span class="k">break</span>
                                <span class="n">otherDur</span> <span class="o">=</span> <span class="n">dur</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">otherCol</span><span class="p">]</span>
                                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">thisNextNdx</span> <span class="o">-</span> <span class="n">ndx</span> <span class="o">-</span> <span class="n">otherDur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">.00003</span><span class="p">:</span>  <span class="c1"># found a valid swap</span>
                                    <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">[</span><span class="n">thisCol</span><span class="p">,</span> <span class="n">otherCol</span><span class="p">]</span>
                                            <span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">[</span><span class="n">otherCol</span><span class="p">,</span> <span class="n">thisCol</span><span class="p">]]</span>
                                    <span class="k">break</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graces</span><span class="p">):</span>  <span class="c1"># add all the grace notes found to col0</span>
                    <span class="n">part0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                        <span class="n">graces</span><span class="p">,</span> <span class="n">graceOffsets</span><span class="p">),</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()))</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>
                    <span class="n">isUnique</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">part0</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="n">part0</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part0</span><span class="p">)</span>
                <span class="n">kernStrands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part0</span><span class="p">)</span>

                <span class="n">strands</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># if df has more than 1 column, iterate over the non-first columns</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                    <span class="n">_copy</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">_copy</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">part0</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_copy</span><span class="p">)</span>
                    <span class="n">dur</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">nrc</span><span class="p">:</span> <span class="n">nrc</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
                    <span class="n">prevEnds</span> <span class="o">=</span> <span class="p">(</span><span class="n">dur</span> <span class="o">+</span> <span class="n">dur</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">()</span>
                    <span class="n">startI</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">endI</span><span class="p">,</span> <span class="n">endNdx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">startI</span><span class="p">:]):</span>
                        <span class="n">endNdx</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">endNdx</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
                        <span class="n">nextNdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">highestTime</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span>
                            <span class="n">part</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">endI</span> <span class="k">else</span> <span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">endI</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">thisDur</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">endI</span><span class="p">]</span><span class="o">.</span><span class="n">quarterLength</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">nextNdx</span> <span class="o">-</span> <span class="n">endNdx</span> <span class="o">-</span> <span class="n">thisDur</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">.00003</span><span class="p">:</span>
                            <span class="n">strand</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">startI</span><span class="p">:</span><span class="n">endI</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="n">strand</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span>
                            <span class="n">divisiStarts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                                <span class="p">(</span><span class="s1">&#39;*^&#39;</span><span class="p">,</span> <span class="s1">&#39;*^&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">startI</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">))</span>
                            <span class="n">joinNdx</span> <span class="o">=</span> <span class="n">endNdx</span> <span class="o">+</span> <span class="n">thisDur</span>        <span class="c1"># find a suitable endpoint to rejoin this strand</span>
                            <span class="n">divisiEnds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="s1">&#39;*v&#39;</span><span class="p">,</span> <span class="s1">&#39;*v&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">(</span>
                                <span class="n">strand</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">joinNdx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">))</span>
                            <span class="n">strands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand</span><span class="p">)</span>
                            <span class="n">startI</span> <span class="o">=</span> <span class="n">endI</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">kernStrands</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="n">strands</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_strand</span><span class="p">:</span> <span class="n">_strand</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_divisiStarts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">divisiStarts</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">divisiEnds</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">de</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">de</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">de</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">prt</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">prt</span> <span class="ow">in</span> <span class="n">kernStrands</span> <span class="k">if</span> <span class="n">prt</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">])</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;level_1&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_divisiEnds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">de</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isUnique</span><span class="p">:</span>
                <span class="n">addTieBreakers</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
                <span class="n">addTieBreakers</span><span class="p">(</span><span class="n">kernStrands</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_partList&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_kernStrands&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernStrands</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_partList&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multi_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kernStrands</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">number</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of the note, rest, and chord objects in the score.</span>

<span class="sd">        The difference between parts and kernStrands is that parts can have voices</span>
<span class="sd">        whereas kernStrands cannot. If there are voices in the _parts DataFrame, the</span>
<span class="sd">        kernStrands DataFrame will include all these notes by adding additional</span>
<span class="sd">        columns.</span>

<span class="sd">        :param multi_index: Boolean, default False. If True, the returned DataFrame</span>
<span class="sd">            will have a MultiIndex.</span>
<span class="sd">        :param kernStrands: Boolean, default False. If True, the method will use the</span>
<span class="sd">            &#39;_kernStrands&#39; analysis.</span>
<span class="sd">        :param compact: Boolean, default False. If True, the method will keep chords</span>
<span class="sd">            unified rather then expanding them into separate columns.</span>
<span class="sd">        :param number: Boolean, default False. If True, the method will 1-index</span>
<span class="sd">            the part names and the voice names making the columns a MultiIndex. Only</span>
<span class="sd">            applies if `compact` is also True.</span>
<span class="sd">        :return: A DataFrame of the note, rest, and chord objects in the score.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_parts&#39;</span><span class="p">,</span> <span class="n">multi_index</span><span class="p">,</span> <span class="n">kernStrands</span><span class="p">,</span> <span class="n">compact</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">toConcat</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">kernStrands</span><span class="p">:</span>
                <span class="n">toConcat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_kernStrands&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">compact</span><span class="p">:</span>
                <span class="n">toConcat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partList</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">number</span><span class="p">:</span>
                    <span class="n">partNameToNum</span> <span class="o">=</span> <span class="p">{</span><span class="n">part</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span>
                                     <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">)}</span>
                    <span class="n">colTuples</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">toConcat</span><span class="p">:</span>
                        <span class="n">names</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">colTuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">partNameToNum</span><span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">colTuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">partNameToNum</span><span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">int</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">mi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span>
                        <span class="n">colTuples</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Staff&#39;</span><span class="p">,</span> <span class="s1">&#39;Layer&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partList</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                        <span class="n">toConcat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">listify</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">nrc</span><span class="p">:</span> <span class="n">nrc</span><span class="o">.</span><span class="n">notes</span> <span class="k">if</span> <span class="n">nrc</span><span class="o">.</span><span class="n">isChord</span> <span class="k">else</span> <span class="p">[</span><span class="n">nrc</span><span class="p">])</span>
                    <span class="n">expanded</span> <span class="o">=</span> <span class="n">listify</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
                    <span class="n">expanded</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">part</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">part</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">expanded</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span>
                    <span class="n">toConcat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expanded</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">toConcat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">toConcat</span><span class="p">)</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multi_index</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">compact</span> <span class="ow">and</span> <span class="n">number</span><span class="p">:</span>
                <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">mi</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_import_other_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import the harmonic function spines from a given path.</span>

<span class="sd">        :param path: A string representing the path to the file containing the </span>
<span class="sd">            harmonic function spines.</span>
<span class="sd">        :return: A pandas DataFrame representing the harmonic function spines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">==</span> <span class="s1">&#39;krn&#39;</span> <span class="ow">or</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">humFile</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">humdrum</span><span class="o">.</span><span class="n">spineParser</span><span class="o">.</span><span class="n">HumdrumFile</span><span class="p">(</span><span class="n">path</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="n">humFile</span><span class="o">.</span><span class="n">parseFilename</span><span class="p">()</span>
            <span class="n">foundSpines</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">keyVals</span><span class="p">,</span> <span class="n">keyPositions</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">gotKeys</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="n">humFile</span><span class="o">.</span><span class="n">spineCollection</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spine</span><span class="o">.</span><span class="n">spineType</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;kern&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="s1">&#39;dynam&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">foundSpines</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spine</span><span class="o">.</span><span class="n">spineType</span><span class="p">)</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">vals</span><span class="p">,</span> <span class="n">valPositions</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keyVals</span><span class="p">):</span>
                    <span class="n">gotKeys</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spine</span><span class="o">.</span><span class="n">eventList</span><span class="p">):</span>
                    <span class="n">contents</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">contents</span>
                    <span class="k">if</span> <span class="n">contents</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">contents</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="c1"># there usually won&#39;t be any m21 objects at the same position as the key events,</span>
                        <span class="c1"># so use the position from the next item in eventList if there is a next item.</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">gotKeys</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine</span><span class="o">.</span><span class="n">eventList</span><span class="p">):</span>
                            <span class="c1"># [1:-1] to remove the * and : characters</span>
                            <span class="n">keyVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">keyPositions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine</span><span class="o">.</span><span class="n">eventList</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">spine</span><span class="o">.</span><span class="n">spineType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;function&#39;</span><span class="p">,</span> <span class="s1">&#39;harm&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">contents</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">contents</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">contents</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">):</span>
                            <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
                            <span class="n">valPositions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">start</span> <span class="ow">or</span> <span class="s1">&#39;!&#39;</span> <span class="ow">in</span> <span class="n">contents</span> <span class="ow">or</span> <span class="s1">&#39;=&#39;</span> <span class="ow">in</span> <span class="n">contents</span> <span class="ow">or</span> <span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">spine</span><span class="o">.</span><span class="n">spineType</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span>
                            <span class="n">functionLabel</span> <span class="o">=</span> <span class="n">function_pattern</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">contents</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">functionLabel</span><span class="p">):</span>
                                <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">functionLabel</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
                        <span class="n">valPositions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

                <span class="n">df1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_priority</span><span class="p">()</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">spine</span><span class="o">.</span><span class="n">spineType</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Cdata&#39;</span><span class="p">:</span>
                    <span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">valPositions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">vals</span><span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">valPositions</span><span class="p">)</span>
                <span class="n">joined</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Priority&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;Cdata&#39;</span><span class="p">:</span>   <span class="c1"># get all the columns from the third to the end. Usually just 1 col except for cdata</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">joined</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">joined</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">res</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">joined</span><span class="p">[</span><span class="s1">&#39;Offset&#39;</span><span class="p">]</span>
                <span class="n">res</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">spine</span><span class="o">.</span><span class="n">spineType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">spine</span><span class="o">.</span><span class="n">spineType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">spine</span><span class="o">.</span><span class="n">spineType</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">gotKeys</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">keyVals</span><span class="p">):</span>
                    <span class="n">keyName</span> <span class="o">=</span> <span class="s1">&#39;keys&#39;</span>
                    <span class="c1"># key records are usually not found at a kern line with notes so take the next valid one</span>
                    <span class="n">keyPositions</span> <span class="o">=</span> <span class="p">[</span><span class="n">df1</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">Priority</span> <span class="o">&gt;=</span> <span class="n">kp</span><span class="p">)[</span>
                        <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">keyPositions</span><span class="p">]</span>
                    <span class="n">df3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">keyName</span><span class="p">:</span> <span class="n">keyVals</span><span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">keyPositions</span><span class="p">)</span>
                    <span class="n">joined</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df3</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Priority&#39;</span><span class="p">)</span>
                    <span class="n">ser</span> <span class="o">=</span> <span class="n">joined</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">ser</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">joined</span><span class="p">[</span><span class="s1">&#39;Offset&#39;</span><span class="p">]</span>
                    <span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">keyName</span><span class="p">]</span> <span class="o">=</span> <span class="n">ser</span>
                    <span class="n">gotKeys</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">foundSpines</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">foundSpines</span> <span class="o">=</span> <span class="n">foundSpines</span>

        <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;function&#39;</span><span class="p">,</span> <span class="s1">&#39;harm&#39;</span><span class="p">,</span> <span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="s1">&#39;chord&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">spine</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;cdata&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;cdata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

<div class="viewcode-block" id="Score.insertScoreDef">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.insertScoreDef">[docs]</a>
    <span class="k">def</span> <span class="nf">insertScoreDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a scoreDef element into an MEI (Music Encoding Initiative) document.</span>

<span class="sd">        This function inserts a scoreDef element into an MEI document if one is</span>
<span class="sd">        not already present. It modifies the input element in-place.</span>

<span class="sd">        :param root: An xml.etree.ElementTree.Element representing the root of the</span>
<span class="sd">            MEI document.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.//scoreDef&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m21Clefs</span><span class="p">()</span>
                <span class="n">ksigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keySignatures</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">tsigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeSignatures</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">tsig1</span> <span class="o">=</span> <span class="n">tsigs</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">scoreDef</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;scoreDef&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span>
                                                   <span class="s1">&#39;meter.count&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tsig1</span><span class="o">.</span><span class="n">numerator</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;meter.unit&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tsig1</span><span class="o">.</span><span class="n">denominator</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scoreDef</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span>
                    <span class="s1">&#39;scoreDef&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">})</span>
            <span class="n">pgHead</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">scoreDef</span><span class="p">,</span> <span class="s1">&#39;pgHead&#39;</span><span class="p">)</span>
            <span class="n">rend1</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                <span class="n">pgHead</span><span class="p">,</span> <span class="s1">&#39;rend&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;halign&#39;</span><span class="p">:</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;valign&#39;</span><span class="p">:</span> <span class="s1">&#39;top&#39;</span><span class="p">})</span>
            <span class="n">rend_title</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                <span class="n">rend1</span><span class="p">,</span> <span class="s1">&#39;rend&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;x-large&#39;</span><span class="p">})</span>
            <span class="n">rend_title</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Untitled score&#39;</span>
            <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">rend1</span><span class="p">,</span> <span class="s1">&#39;lb&#39;</span><span class="p">)</span>
            <span class="n">rend_subtitle</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                <span class="n">rend1</span><span class="p">,</span> <span class="s1">&#39;rend&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;subtitle&#39;</span><span class="p">,</span> <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;large&#39;</span><span class="p">})</span>
            <span class="n">rend_subtitle</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Subtitle&#39;</span>
            <span class="n">rend2</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                <span class="n">pgHead</span><span class="p">,</span> <span class="s1">&#39;rend&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;halign&#39;</span><span class="p">:</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;valign&#39;</span><span class="p">:</span> <span class="s1">&#39;bottom&#39;</span><span class="p">})</span>
            <span class="n">rend_composer</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">rend2</span><span class="p">,</span> <span class="s1">&#39;rend&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;composer&#39;</span><span class="p">})</span>
            <span class="n">rend_composer</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Composer / arranger&#39;</span>
            <span class="n">staffGrp</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">scoreDef</span><span class="p">,</span> <span class="s1">&#39;staffGrp&#39;</span><span class="p">,</span> <span class="p">{</span>
                                     <span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;symbol&#39;</span><span class="p">:</span> <span class="s1">&#39;bracket&#39;</span><span class="p">})</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;Part-</span><span class="si">{</span><span class="n">staff</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">staff</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;staff&#39;</span><span class="p">)})</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">staff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">):</span>
                <span class="n">attribs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">staff</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span>
                    <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;lines&#39;</span><span class="p">:</span> <span class="s1">&#39;5&#39;</span><span class="p">}</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">clef</span> <span class="o">=</span> <span class="n">clefs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;clef.line&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">clef</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;clef.shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clef</span><span class="o">.</span><span class="n">sign</span>
                    <span class="k">if</span> <span class="n">clef</span><span class="o">.</span><span class="n">octaveChange</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;clef.dis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">clef</span><span class="o">.</span><span class="n">octaveChange</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;clef.dis.place&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;below&#39;</span> <span class="k">if</span> <span class="n">clef</span><span class="o">.</span><span class="n">octaveChange</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;above&#39;</span>
                    <span class="n">ksig</span> <span class="o">=</span> <span class="n">ksigs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">ksigs</span><span class="o">.</span><span class="n">empty</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">ksig</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ksig</span><span class="o">.</span><span class="n">alteredPitches</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ksig</span><span class="o">.</span><span class="n">alteredPitches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">accidental</span><span class="o">.</span><span class="n">modifier</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                            <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;key.sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">f&#39;</span>
                        <span class="k">elif</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ksig</span><span class="o">.</span><span class="n">alteredPitches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">accidental</span><span class="o">.</span><span class="n">modifier</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                            <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;key.sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">s&#39;</span>
                <span class="n">staffDef</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">staffGrp</span><span class="p">,</span> <span class="s1">&#39;staffDef&#39;</span><span class="p">,</span> <span class="n">attribs</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">staffDef</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="p">{</span>
                                      <span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
                <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">staff</span>
            <span class="n">scoreEl</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.//score&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scoreEl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scoreEl</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">scoreDef</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.xmlIDs">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.xmlIDs">[docs]</a>
    <span class="k">def</span> <span class="nf">xmlIDs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return xml ids per part in a pandas.DataFrame time-aligned with the</span>
<span class="sd">        objects offset. If the file is not xml or mei, or an idString wasn&#39;t found,</span>
<span class="sd">        return a DataFrame of the ids of the music21 objects.</span>

<span class="sd">        :return: A pandas DataFrame representing the xml ids in the score.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`nmats`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.xmlIDs()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;xmlIDs&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;xmlIDs&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="s1">&#39;mei&#39;</span><span class="p">):</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
            <span class="n">idString</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;}id&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idString</span><span class="p">):</span>
                <span class="n">idString</span> <span class="o">=</span> <span class="n">idString</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">dotCoefficients</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>
                                   <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mf">1.75</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mf">1.875</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mf">1.9375</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">staff</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.//staff&#39;</span><span class="p">):</span>
                    <span class="c1"># doesn&#39;t need &#39;.//&#39; because only looks for direct children of staff elements</span>
                    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">staff</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;layer&#39;</span><span class="p">):</span>
                        <span class="n">column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Staff</span><span class="si">{</span><span class="n">staff</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_Layer</span><span class="si">{</span><span class="n">layer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="n">column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                            <span class="n">data</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">nrb</span> <span class="ow">in</span> <span class="n">layer</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nrb</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;note&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nrb</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;rest&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nrb</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;mRest&#39;</span><span class="p">):</span>
                                <span class="n">data</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nrb</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idString</span><span class="p">))</span>
                            <span class="k">elif</span> <span class="n">nrb</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;beam&#39;</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="n">nrb</span><span class="p">:</span>
                                    <span class="n">data</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idString</span><span class="p">))</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span><span class="n">multi_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                    <span class="n">idCol</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                    <span class="n">idCol</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idCol</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">columns</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;xmlIDs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="k">return</span> <span class="n">df</span>
        <span class="c1"># either not xml/mei, or an idString wasn&#39;t found</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span><span class="n">multi_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;xmlIDs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="n">df</span></div>


    <span class="k">def</span> <span class="nf">_lyricHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">strip</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for the lyrics method.</span>

<span class="sd">        :param cell: A music21 object.</span>
<span class="sd">        :return: The lyric of the music21 object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;lyric&#39;</span><span class="p">):</span>
            <span class="n">lyr</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">lyric</span>
            <span class="k">if</span> <span class="n">lyr</span> <span class="ow">and</span> <span class="n">strip</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lyr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lyr</span> <span class="o">=</span> <span class="n">lyr</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n\t</span><span class="s1">-_&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lyr</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<div class="viewcode-block" id="Score.lyrics">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.lyrics">[docs]</a>
    <span class="k">def</span> <span class="nf">lyrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the lyrics from the score. </span>

<span class="sd">        The lyrics are extracted from each part and returned as a pandas DataFrame </span>
<span class="sd">        where each column represents a part and each row represents a lyric. The </span>
<span class="sd">        DataFrame is indexed by the offset of the lyrics.</span>

<span class="sd">        :param strip: Boolean, default True. If True, the method will strip leading</span>
<span class="sd">            and trailing whitespace from the lyrics.</span>
<span class="sd">        :return: A pandas DataFrame representing the lyrics in the score.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`dynamics`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/Busnoys_In_hydraulis.krn&#39;)</span>
<span class="sd">            piece.lyrics()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;lyrics&#39;</span><span class="p">,</span> <span class="n">strip</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lyricHelper</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                   <span class="o">**</span><span class="p">{</span><span class="s1">&#39;strip&#39;</span><span class="p">:</span> <span class="n">strip</span><span class="p">})</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_m21Clefs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the clefs from the score. </span>

<span class="sd">        The clefs are extracted from each part and returned as a pandas DataFrame </span>
<span class="sd">        where each column represents a part and each row represents a clef. The </span>
<span class="sd">        DataFrame is indexed by the offset of the clefs.</span>

<span class="sd">        :return: A pandas DataFrame of the clefs in the score in music21&#39;s format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_m21Clefs&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">isUnique</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">flat_part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="p">):</span>
                <span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">flat_part</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span>
                    <span class="p">[</span><span class="s1">&#39;Clef&#39;</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">ser</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">nrc</span><span class="p">:</span> <span class="n">nrc</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">ser</span> <span class="o">=</span> <span class="n">ser</span><span class="p">[</span><span class="o">~</span><span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                    <span class="n">isUnique</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ser</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isUnique</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                    <span class="n">tieBreakers</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">nexts</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nexts</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">tieBreakers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tieBreakers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">tieBreakers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">tieBreakers</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="n">part</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">tieBreakers</span><span class="p">))</span>
            <span class="n">clefs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clefs</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">clefs</span> <span class="o">=</span> <span class="n">clefs</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_m21Clefs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clefs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_m21Clefs&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_clefs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the clefs from the score. </span>

<span class="sd">        The clefs are extracted from each part and returned as a pandas DataFrame </span>
<span class="sd">        where each column represents a part and each row represents a clef. The </span>
<span class="sd">        DataFrame is indexed by the offset of the clefs.</span>

<span class="sd">        :return: A pandas DataFrame of the clefs in the score in kern format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_clefs&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_clefs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m21Clefs</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="n">kernClefHelper</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_clefs&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Score.dynamics">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.dynamics">[docs]</a>
    <span class="k">def</span> <span class="nf">dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the dynamics from the score. </span>

<span class="sd">        The dynamics are extracted from each part and returned as a pandas DataFrame </span>
<span class="sd">        where each column represents a part and each row represents a dynamic </span>
<span class="sd">        marking. The DataFrame is indexed by the offset of the dynamic markings.</span>

<span class="sd">        :return: A pandas DataFrame representing the dynamics in the score.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`lyrics`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.dynamics()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;dynamics&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">dyns</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="n">obj</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">sf</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span>
                <span class="s1">&#39;Dynamic&#39;</span><span class="p">)},</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="p">]</span>
            <span class="n">dyns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dyns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dyns</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span>
            <span class="n">dyns</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;dynamics&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dyns</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;dynamics&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For .krn files, get the line numbers of the events in the piece, which </span>
<span class="sd">        music21 often calls &quot;priority&quot;. For other encoding formats return an </span>
<span class="sd">        empty dataframe.</span>

<span class="sd">        :return: A DataFrame containing the priority values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_priority&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">!=</span> <span class="s1">&#39;krn&#39;</span><span class="p">:</span>
                <span class="n">priority</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use compact to avoid losing priorities of chords</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span><span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parts</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">priority</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">priority</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;Int16&#39;</span><span class="p">)</span>
                    <span class="n">priority</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                        <span class="p">{</span><span class="s1">&#39;Priority&#39;</span><span class="p">:</span> <span class="n">priority</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;Offset&#39;</span><span class="p">:</span> <span class="n">priority</span><span class="o">.</span><span class="n">index</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_priority&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">priority</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_priority&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Score.keys">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.keys">[docs]</a>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snap_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the key signature portion of the **harm spine in a kern file if there</span>
<span class="sd">        is one and return it as an array or a time-aligned pandas Series. This is</span>
<span class="sd">        similar to the .harm, .functions, .chords, and .cdata methods. The default</span>
<span class="sd">        is for the results to be returned as a 1-d array, but you can set `output=&#39;series&#39;`</span>
<span class="sd">        for a pandas series instead. If want to get the results of a different spine</span>
<span class="sd">        type (i.e. not one of the ones listed above), see :meth:`getSpines`.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.keys()</span>

<span class="sd">        If you want to align these results so that they match the columnar (time) axis</span>
<span class="sd">        of the pianoRoll, sampled, or mask results, you can pass the pianoRoll or mask</span>
<span class="sd">        that you want to align to as the `snap_to` parameter. Doing that makes it easier</span>
<span class="sd">        to combine these results with any of the pianoRoll, sampled, or mask tables to</span>
<span class="sd">        have both in a single table which can make data analysis easier. Passing a `snap_to`</span>
<span class="sd">        argument will automatically cause the return value to be a pandas series since</span>
<span class="sd">        that&#39;s facilitates combining the two. Here&#39;s how you would use the `snap_to`</span>
<span class="sd">        parameter and then combine the results with the pianoRoll to create a single table.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            pianoRoll = piece.pianoRoll()</span>
<span class="sd">            keys = piece.keys(snap_to=pianoRoll)</span>
<span class="sd">            combined = pd.concat((pianoRoll, keys))</span>

<span class="sd">        The `sampled` and `mask` dfs often have more observations than the spine </span>
<span class="sd">        contents, so you may want to fill in these new empty slots somehow. The kern </span>
<span class="sd">        format uses &#39;.&#39; as a filler token so you can pass this as the `filler` </span>
<span class="sd">        parameter to fill all the new empty slots with this as well. If you choose </span>
<span class="sd">        some other value, say `filler=&#39;_&#39;`, then in addition to filling in the empty </span>
<span class="sd">        slots with underscores, this will also replace the kern &#39;.&#39; observations with </span>
<span class="sd">        &#39;_&#39;. If you want to fill them in with NaN&#39;s as pandas usually does, you can </span>
<span class="sd">        pass `filler=&#39;nan&#39;` as a convenience. If you want to &quot;forward fill&quot; these </span>
<span class="sd">        results, you can pass `filler=&#39;forward&#39;` (default). This will propagate the </span>
<span class="sd">        last non-period (&#39;.&#39;) observation until a new one is found. Finally, you can </span>
<span class="sd">        pass filler=&#39;drop&#39; to drop all empty observations (both NaNs and humdrum</span>
<span class="sd">        periods).</span>

<span class="sd">        :param snap_to: A pandas DataFrame to align the results to. Default is None.</span>
<span class="sd">        :param filler: A string representing the filler token. Default is &#39;forward&#39;.</span>
<span class="sd">        :param output: A string representing the output format. Default is &#39;array&#39;.</span>
<span class="sd">        :return: A numpy array or pandas Series representing the harmonic keys</span>
<span class="sd">            analysis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`cdata`</span>
<span class="sd">        :meth:`chords`</span>
<span class="sd">        :meth:`functions`</span>
<span class="sd">        :meth:`harm`</span>
<span class="sd">        :meth:`getSpines`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">snap_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;series&#39;</span>
        <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;keys&#39;</span><span class="p">],</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.harm">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.harm">[docs]</a>
    <span class="k">def</span> <span class="nf">harm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snap_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the harmonic analysis portion of the **harm spine in a kern file if there</span>
<span class="sd">        is one and return it as an array or a time-aligned pandas Series. The prevailing</span>
<span class="sd">        key signature information is not included here from the harm spine, but that key</span>
<span class="sd">        information is available in the .keys method. This is similar to the</span>
<span class="sd">        .keys, .functions, .chords, and .cdata methods. The default is for the</span>
<span class="sd">        results to be returned as a 1-d array, but you can set `output=&#39;series&#39;`</span>
<span class="sd">        for a pandas series instead which is helpful if you&#39;re going to concatenate</span>
<span class="sd">        the results to a dataframe. If want to get the results of a different spine</span>
<span class="sd">        type (i.e. not one of the ones listed above), see :meth:`getSpines`.</span>

<span class="sd">        If you want to align these results so that they match the columnar (time) axis</span>
<span class="sd">        of the pianoRoll, sampled, or mask results, you can pass the pianoRoll or mask</span>
<span class="sd">        that you want to align to as the `snap_to` parameter. Doing that makes it easier</span>
<span class="sd">        to combine these results with any of the pianoRoll, sampled, or mask tables to</span>
<span class="sd">        have both in a single table which can make data analysis easier. Passing a `snap_to`</span>
<span class="sd">        argument will automatically cause the return value to be a pandas series since</span>
<span class="sd">        that&#39;s facilitates combining the two. Here&#39;s how you would use the `snap_to`</span>
<span class="sd">        parameter and then combine the results with the pianoRoll to create a single table.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            pianoRoll = piece.pianoRoll()</span>
<span class="sd">            harm = piece.harm(snap_to=pianoRoll, output=&#39;series&#39;)</span>
<span class="sd">            combined = pd.concat((pianoRoll, harm))</span>

<span class="sd">        The `sampled` and `mask` dfs often have more observations than the spine </span>
<span class="sd">        contents, so you may want to fill in these new empty slots somehow. The kern </span>
<span class="sd">        format uses &#39;.&#39; as a filler token so you can pass this as the `filler` </span>
<span class="sd">        parameter to fill all the new empty slots with this as well. If you choose </span>
<span class="sd">        some other value, say `filler=&#39;_&#39;`, then in addition to filling in the empty </span>
<span class="sd">        slots with underscores, this will also replace the kern &#39;.&#39; observations with </span>
<span class="sd">        &#39;_&#39;. If you want to fill them in with NaN&#39;s as pandas usually does, you can </span>
<span class="sd">        pass `filler=&#39;nan&#39;` as a convenience. If you want to &quot;forward fill&quot; these </span>
<span class="sd">        results, you can pass `filler=&#39;forward&#39;` (default). This will propagate the </span>
<span class="sd">        last non-period (&#39;.&#39;) observation until a new one is found. Finally, you can </span>
<span class="sd">        pass filler=&#39;drop&#39; to drop all empty observations (both NaNs and humdrum</span>
<span class="sd">        periods).</span>

<span class="sd">        :param snap_to: A pandas DataFrame to align the results to. Default is None.</span>
<span class="sd">        :param filler: A string representing the filler token. Default is &#39;forward&#39;.</span>
<span class="sd">        :param output: A string representing the output format. Default is &#39;array&#39;.</span>
<span class="sd">        :return: A numpy array or pandas Series representing the harmonic keys</span>
<span class="sd">            analysis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`cdata`</span>
<span class="sd">        :meth:`chords`</span>
<span class="sd">        :meth:`functions`</span>
<span class="sd">        :meth:`keys`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;harm&#39;</span><span class="p">],</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.functions">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.functions">[docs]</a>
    <span class="k">def</span> <span class="nf">functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snap_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the harmonic function labels from a **function spine in a kern file if there</span>
<span class="sd">        is one and return it as an array or a time-aligned pandas Series. This is</span>
<span class="sd">        similar to the .harm, .keys, .chords, and .cdata methods. The default</span>
<span class="sd">        is for the results to be returned as a 1-d array, but you can set `output=&#39;series&#39;`</span>
<span class="sd">        for a pandas series instead. If want to get the results of a different spine</span>
<span class="sd">        type (i.e. not one of the ones listed above), see :meth:`getSpines`.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.functions()</span>

<span class="sd">        If you want to align these results so that they match the columnar (time) axis</span>
<span class="sd">        of the pianoRoll, sampled, or mask results, you can pass the pianoRoll or mask</span>
<span class="sd">        that you want to align to as the `snap_to` parameter. Doing that makes it easier</span>
<span class="sd">        to combine these results with any of the pianoRoll, sampled, or mask tables to</span>
<span class="sd">        have both in a single table which can make data analysis easier. Passing a `snap_to`</span>
<span class="sd">        argument will automatically cause the return value to be a pandas series since</span>
<span class="sd">        that&#39;s facilitates combining the two. Here&#39;s how you would use the `snap_to`</span>
<span class="sd">        parameter and then combine the results with the pianoRoll to create a single table.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            pianoRoll = piece.pianoRoll()</span>
<span class="sd">            functions = piece.functions(snap_to=pianoRoll)</span>
<span class="sd">            combined = pd.concat((pianoRoll, functions))</span>

<span class="sd">        The `sampled` and `mask` dfs often have more observations than the spine </span>
<span class="sd">        contents, so you may want to fill in these new empty slots somehow. The kern </span>
<span class="sd">        format uses &#39;.&#39; as a filler token so you can pass this as the `filler` </span>
<span class="sd">        parameter to fill all the new empty slots with this as well. If you choose </span>
<span class="sd">        some other value, say `filler=&#39;_&#39;`, then in addition to filling in the empty </span>
<span class="sd">        slots with underscores, this will also replace the kern &#39;.&#39; observations with </span>
<span class="sd">        &#39;_&#39;. If you want to fill them in with NaN&#39;s as pandas usually does, you can </span>
<span class="sd">        pass `filler=&#39;nan&#39;` as a convenience. If you want to &quot;forward fill&quot; these </span>
<span class="sd">        results, you can pass `filler=&#39;forward&#39;` (default). This will propagate the </span>
<span class="sd">        last non-period (&#39;.&#39;) observation until a new one is found. Finally, you can </span>
<span class="sd">        pass filler=&#39;drop&#39; to drop all empty observations (both NaNs and humdrum</span>
<span class="sd">        periods).</span>

<span class="sd">        :param snap_to: A pandas DataFrame to align the results to. Default is None.</span>
<span class="sd">        :param filler: A string representing the filler token. Default is &#39;forward&#39;.</span>
<span class="sd">        :param output: A string representing the output format. Default is &#39;array&#39;.</span>
<span class="sd">        :return: A numpy array or pandas Series representing the harmonic keys</span>
<span class="sd">            analysis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`cdata`</span>
<span class="sd">        :meth:`chords`</span>
<span class="sd">        :meth:`harm`</span>
<span class="sd">        :meth:`keys`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">snap_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;series&#39;</span>
        <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">],</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.chords">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.chords">[docs]</a>
    <span class="k">def</span> <span class="nf">chords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snap_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the chord labels from the **chord spine in a kern file if there</span>
<span class="sd">        is one and return it as an array or a time-aligned pandas Series. This is</span>
<span class="sd">        similar to the .functions, .harm, .keys, and .cdata methods. The default</span>
<span class="sd">        is for the results to be returned as a 1-d array, but you can set `output=&#39;series&#39;`</span>
<span class="sd">        for a pandas series instead. If want to get the results of a different spine</span>
<span class="sd">        type (i.e. not one of the ones listed above), see :meth:`getSpines`.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.chords()</span>

<span class="sd">        If you want to align these results so that they match the columnar (time) axis</span>
<span class="sd">        of the pianoRoll, sampled, or mask results, you can pass the pianoRoll or mask</span>
<span class="sd">        that you want to align to as the `snap_to` parameter. Doing that makes it easier</span>
<span class="sd">        to combine these results with any of the pianoRoll, sampled, or mask tables to</span>
<span class="sd">        have both in a single table which can make data analysis easier. Passing a `snap_to`</span>
<span class="sd">        argument will automatically cause the return value to be a pandas series since</span>
<span class="sd">        that&#39;s facilitates combining the two. Here&#39;s how you would use the `snap_to`</span>
<span class="sd">        parameter and then combine the results with the pianoRoll to create a single table.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            pianoRoll = piece.pianoRoll()</span>
<span class="sd">            chords = piece.chords(snap_to=pianoRoll)</span>
<span class="sd">            combined = pd.concat((pianoRoll, chords))</span>

<span class="sd">        The `sampled` and `mask` dfs often have more observations than the spine </span>
<span class="sd">        contents, so you may want to fill in these new empty slots somehow. The kern </span>
<span class="sd">        format uses &#39;.&#39; as a filler token so you can pass this as the `filler` </span>
<span class="sd">        parameter to fill all the new empty slots with this as well. If you choose </span>
<span class="sd">        some other value, say `filler=&#39;_&#39;`, then in addition to filling in the empty </span>
<span class="sd">        slots with underscores, this will also replace the kern &#39;.&#39; observations with </span>
<span class="sd">        &#39;_&#39;. If you want to fill them in with NaN&#39;s as pandas usually does, you can </span>
<span class="sd">        pass `filler=&#39;nan&#39;` as a convenience. If you want to &quot;forward fill&quot; these </span>
<span class="sd">        results, you can pass `filler=&#39;forward&#39;` (default). This will propagate the </span>
<span class="sd">        last non-period (&#39;.&#39;) observation until a new one is found. Finally, you can </span>
<span class="sd">        pass filler=&#39;drop&#39; to drop all empty observations (both NaNs and humdrum</span>
<span class="sd">        periods).</span>

<span class="sd">        :param snap_to: A pandas DataFrame to align the results to. Default is None.</span>
<span class="sd">        :param filler: A string representing the filler token. Default is &#39;forward&#39;.</span>
<span class="sd">        :param output: A string representing the output format. Default is &#39;array&#39;.</span>
<span class="sd">        :return: A numpy array or pandas Series representing the harmonic keys</span>
<span class="sd">            analysis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`cdata`</span>
<span class="sd">        :meth:`functions`</span>
<span class="sd">        :meth:`harm`</span>
<span class="sd">        :meth:`keys`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">snap_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;series&#39;</span>
        <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;chord&#39;</span><span class="p">],</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.cdata">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.cdata">[docs]</a>
    <span class="k">def</span> <span class="nf">cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snap_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the cdata records from **cdata spines in a kern file if there</span>
<span class="sd">        are any and return it as a pandas DataFrame. This is</span>
<span class="sd">        similar to the .harm, .functions, .chords, and .keys methods, with the</span>
<span class="sd">        exception that this method defaults to returning a dataframe since there are</span>
<span class="sd">        often more than one cdata spine in a kern score. If want to get the results</span>
<span class="sd">        of a different spine type (i.e. not one of the ones listed above), see</span>
<span class="sd">        :meth:`getSpines`.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.cdata()</span>

<span class="sd">        If you want to align these results so that they match the columnar (time) axis</span>
<span class="sd">        of the pianoRoll, sampled, or mask results, you can pass the pianoRoll or mask</span>
<span class="sd">        that you want to align to as the `snap_to` parameter. Doing that makes it easier</span>
<span class="sd">        to combine these results with any of the pianoRoll, sampled, or mask tables to</span>
<span class="sd">        have both in a single table which can make data analysis easier. Passing a `snap_to`</span>
<span class="sd">        argument will automatically cause the return value to be a pandas series since</span>
<span class="sd">        that&#39;s facilitates combining the two. Here&#39;s how you would use the `snap_to`</span>
<span class="sd">        parameter and then combine the results with the pianoRoll to create a single table.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            pianoRoll = piece.pianoRoll()</span>
<span class="sd">            cdata = piece.cdata(snap_to=pianoRoll)</span>
<span class="sd">            combined = pd.concat((pianoRoll, cdata))</span>

<span class="sd">        The `sampled` and `mask` dfs often have more observations than the spine </span>
<span class="sd">        contents, so you may want to fill in these new empty slots somehow. The kern </span>
<span class="sd">        format uses &#39;.&#39; as a filler token so you can pass this as the `filler` </span>
<span class="sd">        parameter to fill all the new empty slots with this as well. If you choose </span>
<span class="sd">        some other value, say `filler=&#39;_&#39;`, then in addition to filling in the empty </span>
<span class="sd">        slots with underscores, this will also replace the kern &#39;.&#39; observations with </span>
<span class="sd">        &#39;_&#39;. If you want to fill them in with NaN&#39;s as pandas usually does, you can </span>
<span class="sd">        pass `filler=&#39;nan&#39;` as a convenience. If you want to &quot;forward fill&quot; these </span>
<span class="sd">        results, you can pass `filler=&#39;forward&#39;` (default). This will propagate the </span>
<span class="sd">        last non-period (&#39;.&#39;) observation until a new one is found. Finally, you can </span>
<span class="sd">        pass filler=&#39;drop&#39; to drop all empty observations (both NaNs and humdrum</span>
<span class="sd">        periods).</span>

<span class="sd">        :param snap_to: A pandas DataFrame to align the results to. Default is None.</span>
<span class="sd">        :param filler: A string representing the filler token. Default is &#39;forward&#39;.</span>
<span class="sd">        :param output: A string representing the output format. Default is &#39;array&#39;.</span>
<span class="sd">        :return: A numpy array or pandas Series representing the harmonic keys</span>
<span class="sd">            analysis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`chords`</span>
<span class="sd">        :meth:`functions`</span>
<span class="sd">        :meth:`harm`</span>
<span class="sd">        :meth:`keys`</span>
<span class="sd">        :meth:`getSpines`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">snap_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;dataframe&#39;</span>
        <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;cdata&#39;</span><span class="p">],</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.getSpines">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.getSpines">[docs]</a>
    <span class="k">def</span> <span class="nf">getSpines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spineType</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pandas DataFrame of a less common spine type. This method is a</span>
<span class="sd">        window into the vast ecosystem of Humdrum tools making them accessible to</span>
<span class="sd">        pyAMPACT.</span>

<span class="sd">        :param spineType: A string representing the spine type to return. You can</span>
<span class="sd">            pass the spine type with or without the &quot;**&quot; prefix.</span>
<span class="sd">        :return: A pandas DataFrame of the given spine type.</span>

<span class="sd">        Similar to the .harm, .keys, .functions, .chords, and .cdata methods, this</span>
<span class="sd">        method returns the contents of a specific spine type from a kern file. This is</span>
<span class="sd">        a generic method that can be used to get the contents of any spine type other</span>
<span class="sd">        than: **kern, **dynam, **text, **cdata, **chord, **harm, or **function. Many</span>
<span class="sd">        of the other spine types that you may be interested provide partwise data.</span>
<span class="sd">        For example, the results of Humlib&#39;s Renaissance dissonance analysis are given</span>
<span class="sd">        as one &quot;**cdata-rdiss&quot; spine per part. Note that a **cdata-rdiss spine is not</span>
<span class="sd">        the same as a **cdata spine. This is why we return a DataFrame rather than</span>
<span class="sd">        an array or series. If there is just one spine of the spine type you request,</span>
<span class="sd">        the data will still be given as a 1-column dataframe. When you import a kern</span>
<span class="sd">        file, it automatically gets scanned for other spine types and if any are found</span>
<span class="sd">        you can see them with the `foundSpines` attribute.</span>

<span class="sd">        This example takes a score with **cdata-rdiss spines (Renaissance dissonance</span>
<span class="sd">        analysis), and makes a DataFrame of just the **cdata-rdiss spines. The full</span>
<span class="sd">        score with color-coded dissonance labels can be seen on the Verovio Humdrum</span>
<span class="sd">        Viewer `here &lt;https://verovio.humdrum.org/?k=ey&amp;filter=dissonant%20--color&amp;file=jrp:Tin2004&gt;`_.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/O_Virgo_Miserere.krn&#39;)</span>
<span class="sd">            rdiss = piece.getSpines(&#39;cdata-rdiss&#39;)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`cdata`</span>
<span class="sd">        :meth:`chords`</span>
<span class="sd">        :meth:`dynamics`</span>
<span class="sd">        :meth:`functions`</span>
<span class="sd">        :meth:`harm`</span>
<span class="sd">        :meth:`keys`</span>
<span class="sd">        :meth:`lyrics`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">spineType</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">):</span>
            <span class="n">spineType</span> <span class="o">=</span> <span class="n">spineType</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;foundSpines&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">spineType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">foundSpines</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">snapTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">spineType</span><span class="p">],</span>
                         <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">!=</span> <span class="s1">&#39;krn&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">***This is not a kern file so there are no spines to import.***&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">***No </span><span class="si">{</span><span class="n">spineType</span><span class="si">}</span><span class="s1"> spines were found.***&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.dez">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.dez">[docs]</a>
    <span class="k">def</span> <span class="nf">dez</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the labels data from a .dez file/url and return it as a dataframe. Calls</span>
<span class="sd">        fromJSON to do this. The &quot;meta&quot; portion of the dez file is ignored. If no</span>
<span class="sd">        path is provided, the last dez table imported with this method is returned.</span>

<span class="sd">        :param path: A string representing the path to the .dez file.</span>
<span class="sd">        :return: A pandas DataFrame representing the labels in the .dez file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;dez&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;No path was provided and no prior analysis was found. Please provide a path to a .dez file.&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.dez&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The file provided is not a .dez file.&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The file provided does not exist.&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;dez&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">path</span><span class="p">:</span> <span class="n">fromJSON</span><span class="p">(</span><span class="n">path</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>   <span class="c1"># return the last dez table</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;dez&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;dez&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;dez&#39;</span><span class="p">][</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">fromJSON</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;dez&#39;</span><span class="p">][</span><span class="n">path</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.form">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.form">[docs]</a>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snap_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">,</span> <span class="n">dez_path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the &quot;Structure&quot; labels from a .dez file/url and return it as an array or a</span>
<span class="sd">        time-aligned pandas Series. The default is for the results to be returned as a 1-d</span>
<span class="sd">        array, but you can set `output=&#39;series&#39;` for a pandas series instead. If you want to align</span>
<span class="sd">        these results so that they match the columnar (time) axis of the pianoRoll, sampled, or</span>
<span class="sd">        mask results, you can pass the pianoRoll or mask that you want to align to as the `snap_to`</span>
<span class="sd">        parameter. Doing that makes it easier to combine these results with any of the pianoRoll,</span>
<span class="sd">        sampled, or mask tables to have both in a single table which can make data analysis easier.</span>
<span class="sd">        This example shows how to get the form analysis from a .dez file.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;test_files/K279-1.krn&#39;)</span>
<span class="sd">            form = piece.form(dez_path=&#39;test_files/K279-1_harmony_texture.dez&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dez_path</span> <span class="ow">and</span> <span class="s1">&#39;dez&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No .dez file was found.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dez</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dez</span><span class="p">(</span><span class="n">dez_path</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">dez</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Structure&#39;</span><span class="p">),</span> <span class="s1">&#39;tag&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No &quot;Structure&quot; analysis was found in the .dez file.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.romanNumerals">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.romanNumerals">[docs]</a>
    <span class="k">def</span> <span class="nf">romanNumerals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snap_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">,</span> <span class="n">dez_path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the roman numeral labels from a .dez file/url or **harm spine and return it as an array</span>
<span class="sd">        or a time-aligned pandas Series. The default is for the results to be returned as a 1-d</span>
<span class="sd">        array, but you can set `output=&#39;series&#39;` for a pandas series instead. If you want to align</span>
<span class="sd">        these results so that they match the columnar (time) axis of the pianoRoll, sampled, or mask</span>
<span class="sd">        results, you can pass the pianoRoll or mask that you want to align to as the `snap_to` parameter.</span>
<span class="sd">        Doing that makes it easier to combine these results with any of the pianoRoll, sampled, or mask</span>
<span class="sd">        tables to have both in a single table which can make data analysis easier. This example shows</span>
<span class="sd">        how to get the roman numeral analysis from a kern score that has a **harm spine.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            pianoRoll = piece.pianoRoll()</span>
<span class="sd">            romanNumerals = piece.romanNumerals(snap_to=pianoRoll)</span>

<span class="sd">        The next example shows how to get the roman numeral analysis from a .dez file.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;test_files/K279-1.krn&#39;)</span>
<span class="sd">            romanNumerals = piece.romanNumerals(dez_path=&#39;test_files/K279-1_harmony_texture.dez&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dez_path</span> <span class="ow">or</span> <span class="s1">&#39;dez&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">dez</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dez</span><span class="p">(</span><span class="n">dez_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dez</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">dez</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Harmony&#39;</span><span class="p">),</span> <span class="s1">&#39;tag&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s1">&#39;No &quot;Harmony&quot; analysis was found in the .dez file, checking for a **harm spine.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;harm&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;harm&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">harm</span><span class="p">(</span><span class="n">snap_to</span><span class="o">=</span><span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="o">=</span><span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Neither a dez nor a **harm spine was found so using music21 to get roman numerals...&#39;</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>
        <span class="n">chords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">chordify</span><span class="p">()</span><span class="o">.</span><span class="n">recurse</span><span class="p">()</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="s1">&#39;Chord&#39;</span><span class="p">)</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chords</span><span class="p">]</span>
        <span class="n">figures</span> <span class="o">=</span> <span class="p">[</span><span class="n">m21</span><span class="o">.</span><span class="n">roman</span><span class="o">.</span><span class="n">romanNumeralFromChord</span><span class="p">(</span>
            <span class="n">ch</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">figure</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chords</span><span class="p">]</span>
        <span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">figures</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Roman Numerals&#39;</span><span class="p">)</span>
        <span class="n">ser</span> <span class="o">=</span> <span class="n">ser</span><span class="p">[</span><span class="n">ser</span> <span class="o">!=</span> <span class="n">ser</span><span class="o">.</span><span class="n">shift</span><span class="p">()]</span>   <span class="c1"># remove consecutive duplicates</span>
        <span class="k">return</span> <span class="n">snapTo</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">snap_to</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_m21ObjectsNoTies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove tied notes in a given voice. Only the first note in a tied group </span>
<span class="sd">        will be kept.</span>

<span class="sd">        :param voice: A music21 stream Voice object.</span>
<span class="sd">        :return: A list of music21 objects with ties removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_m21ObjectsNoTies&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_m21ObjectsNoTies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span>
                <span class="n">multi_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">removeTied</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_m21ObjectsNoTies&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_measures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of the measure starting points.</span>

<span class="sd">        :param compact: Boolean, default False. If True, the method will keep</span>
<span class="sd">            chords unified rather then expanding them into separate columns.</span>
<span class="sd">        :return: A DataFrame where each column corresponds to a part in the score,</span>
<span class="sd">            and each row index is the offset of a measure start. The values are </span>
<span class="sd">            the measure numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;_measures&#39;</span><span class="p">,</span> <span class="n">compact</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">partCols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span><span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">partMeasures</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="p">):</span>
                <span class="n">meas</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">measureNumber</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">makeMeasures</span><span class="p">(</span>
                <span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m21</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Measure</span><span class="p">)}</span>
                <span class="n">ser</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">meas</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;Int16&#39;</span><span class="p">)]</span>
                <span class="n">voiceCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">partCols</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span>
                <span class="n">partMeasures</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ser</span> <span class="o">*</span> <span class="n">voiceCount</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">partMeasures</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">partCols</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_measures&#39;</span><span class="p">,</span> <span class="n">compact</span><span class="p">)]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_measures&#39;</span><span class="p">,</span> <span class="n">compact</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_barlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of barlines specifying which barline type.</span>

<span class="sd">        Double barline, for example, can help detect section divisions, and the </span>
<span class="sd">        final barline can help process the `highestTime` similar to music21.</span>

<span class="sd">        :return: A DataFrame where each column corresponds to a part in the score,</span>
<span class="sd">            and each row index is the offset of a barline. The values are the </span>
<span class="sd">            barline types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;_barlines&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">partBarlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="n">bar</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span> <span class="n">bar</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">bar</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">([</span><span class="s1">&#39;Barline&#39;</span><span class="p">])})</span>
                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="p">)]</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">partBarlines</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s2">&quot;_barlines&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s2">&quot;_barlines&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_keySignatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kern</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of key signatures for each part in the score.</span>

<span class="sd">        :param kern: Boolean, default True. If True, the key signatures are </span>
<span class="sd">            returned in the **kern format.</span>
<span class="sd">        :return: A DataFrame where each column corresponds to a part in the score,</span>
<span class="sd">            and each row index is the offset of a key signature. The values are </span>
<span class="sd">            the key signatures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;_keySignatures&#39;</span><span class="p">,</span> <span class="n">kern</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">kSigs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="p">):</span>
                <span class="n">kSigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="n">ky</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span> <span class="n">ky</span> <span class="k">for</span> <span class="n">ky</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span>
                    <span class="p">[</span><span class="s1">&#39;KeySignature&#39;</span><span class="p">])},</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">kSigs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kern</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="s1">&#39;*k[&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ky</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">_note</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">_note</span> <span class="ow">in</span> <span class="n">ky</span><span class="o">.</span><span class="n">alteredPitches</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_keySignatures&#39;</span><span class="p">,</span> <span class="n">kern</span><span class="p">)]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_keySignatures&#39;</span><span class="p">,</span> <span class="n">kern</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_timeSignatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of time signatures for each part in the score.</span>

<span class="sd">        :return: A DataFrame where each column corresponds to a part in the score,</span>
<span class="sd">            and each row index is the offset of a time signature. The values are </span>
<span class="sd">            the time signatures in ratio string format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;_timeSignatures&#39;</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">tsigs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatParts</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ratio</span><span class="p">:</span>
                    <span class="n">tsigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">ts</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span> <span class="n">ts</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">getTimeSignatures</span><span class="p">()},</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tsigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">ts</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span> <span class="n">ts</span><span class="o">.</span><span class="n">ratioString</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">getTimeSignatures</span><span class="p">()},</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">tsigs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_timeSignatures&#39;</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;_timeSignatures&#39;</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)]</span>

<div class="viewcode-block" id="Score.durations">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.durations">[docs]</a>
    <span class="k">def</span> <span class="nf">durations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multi_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of durations of note and rest objects in the piece.</span>

<span class="sd">        If a DataFrame is provided as `df`, the method calculates the difference </span>
<span class="sd">        between cell offsets per column in the passed DataFrame, skipping </span>
<span class="sd">        memoization.</span>

<span class="sd">        :param multi_index: Boolean, default False. If True, the returned DataFrame </span>
<span class="sd">            will have a MultiIndex.</span>
<span class="sd">        :param df: Optional DataFrame. If provided, the method calculates the </span>
<span class="sd">            difference between cell offsets per column in this DataFrame.</span>
<span class="sd">        :return: A DataFrame of durations of note and rest objects in the piece.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`notes`</span>
<span class="sd">            Return a DataFrame of the notes and rests given in American Standard</span>
<span class="sd">            Pitch Notation</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.durations()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;durations&#39;</span><span class="p">,</span> <span class="n">multi_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
                <span class="n">m21objs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m21ObjectsNoTies</span><span class="p">()</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">m21objs</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">nrc</span><span class="p">:</span> <span class="n">nrc</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">,</span>
                                  <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">multi_index</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># df is not None so calculate diff between cell offsets per column in passed df, skip memoization</span>
            <span class="n">sers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="n">ndx</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ndx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">part</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">highestTime</span> <span class="o">-</span> <span class="n">ndx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">sers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">sers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multi_index</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="Score.midi_ticks_durations">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.midi_ticks_durations">[docs]</a>
    <span class="k">def</span> <span class="nf">midi_ticks_durations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces the placeholder ONSET_SEC and OFFSET_SEC columns with specific placements calculated by MIDI</span>
<span class="sd">        tick information. The method translates the music21 stream to MIDI and replaces the values accordingly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`notes`</span>
<span class="sd">            Return a DataFrame of the newly calculated ONSET_SEC and OFFSET_SEC times, and DURATION</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.durations()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Convert music21 stream to MIDI</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">midi_file</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mf</span> <span class="o">=</span> <span class="n">m21</span><span class="o">.</span><span class="n">midi</span><span class="o">.</span><span class="n">translate</span><span class="o">.</span><span class="n">music21ObjectToMidiFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.mid&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">temp_midi_file</span><span class="p">:</span>
            <span class="n">mf</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">temp_midi_file</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
            <span class="n">mf</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
            <span class="n">mf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">midi_file</span> <span class="o">=</span> <span class="n">temp_midi_file</span><span class="o">.</span><span class="n">name</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">mido</span><span class="o">.</span><span class="n">MidiFile</span><span class="p">(</span><span class="n">midi_file</span><span class="p">)</span>
        <span class="c1"># Logic from durations_from_midi_ticks</span>
        <span class="n">onsOffsList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Default PPQN and tempo values</span>
        <span class="n">ppqn</span> <span class="o">=</span> <span class="mi">9600</span>
        <span class="n">current_tempo</span> <span class="o">=</span> <span class="mi">500000</span>

        <span class="c1"># Check for tempo metadata in the MIDI file</span>
        <span class="k">for</span> <span class="n">track</span> <span class="ow">in</span> <span class="n">mid</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">track</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;set_tempo&#39;</span><span class="p">:</span>
                    <span class="n">current_tempo</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">tempo</span>
                    <span class="k">break</span>  <span class="c1"># No need to check further messages in the same track</span>

        <span class="c1"># Convert ticks per beat to seconds per tick</span>
        <span class="n">seconds_per_tick</span> <span class="o">=</span> <span class="n">current_tempo</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1_000_000</span> <span class="o">*</span> <span class="n">ppqn</span><span class="p">)</span>

        <span class="c1"># Check if index is out of range</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mid</span><span class="o">.</span><span class="n">tracks</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> is out of range. Total number of tracks is </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mid</span><span class="o">.</span><span class="n">tracks</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span>

        <span class="c1"># for track in mid.tracks:</span>
        <span class="n">cum_time</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">mid</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;end_of_track&#39;</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c1"># Stop processing this track upon encountering end_of_track</span>
            <span class="n">cum_time</span> <span class="o">+=</span> <span class="n">msg</span><span class="o">.</span><span class="n">time</span>

            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;note_on&#39;</span> <span class="ow">and</span> <span class="n">msg</span><span class="o">.</span><span class="n">velocity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">note</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">note</span>
                <span class="n">velocity</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">velocity</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="n">cum_time</span> <span class="o">*</span> <span class="n">seconds_per_tick</span>
                <span class="n">onsOffsList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start_time</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;note_off&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;note_on&#39;</span> <span class="ow">and</span> <span class="n">msg</span><span class="o">.</span><span class="n">velocity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">onsOffsList</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cum_time</span> <span class="o">*</span> <span class="n">seconds_per_tick</span><span class="p">:</span>
                        <span class="n">end_time</span> <span class="o">=</span> <span class="n">cum_time</span> <span class="o">*</span> <span class="n">seconds_per_tick</span>
                        <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_time</span>
                        <span class="k">break</span>
        <span class="c1"># Replace values in DataFrame</span>
        <span class="n">onsOffsList</span> <span class="o">=</span> <span class="n">truncate_and_scale_onsOffsList</span><span class="p">(</span>
            <span class="n">onsOffsList</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">onsOffsList</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">,</span> <span class="s1">&#39;OFFSET_SEC&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Update the columns with new values from `res`</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;OFFSET_SEC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;OFFSET_SEC&#39;</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;DURATION&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;OFFSET_SEC&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="Score.contextualize">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.contextualize">[docs]</a>
    <span class="k">def</span> <span class="nf">contextualize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">measures</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">beats</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add measure and beat numbers to a DataFrame.</span>

<span class="sd">        :param df: A DataFrame to which to add measure and beat numbers.</span>
<span class="sd">        :param measures: Boolean, default True. If True, measure numbers will be added.</span>
<span class="sd">        :param beats: Boolean, default True. If True, beat numbers will be added.</span>
<span class="sd">        :return: A DataFrame with measure and beat numbers added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_copy</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_copy</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;XML_ID&#39;</span><span class="p">:</span>
            <span class="n">_copy</span><span class="p">[</span><span class="s1">&#39;XML_ID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">_copy</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">_copy</span><span class="p">[</span><span class="s1">&#39;ONSET&#39;</span><span class="p">]</span>
        <span class="n">col_names</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">_copy</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_copy</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
        <span class="n">_copy</span> <span class="o">=</span> <span class="n">_copy</span><span class="p">[</span><span class="o">~</span><span class="n">_copy</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)]</span>
        <span class="n">toConcat</span> <span class="o">=</span> <span class="p">[</span><span class="n">_copy</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">measures</span><span class="p">:</span>
            <span class="n">meas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measures</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">meas</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Measure&#39;</span>
            <span class="n">toConcat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Measure&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">beats</span><span class="p">:</span>
            <span class="n">bts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beats</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">first_valid_index</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">bts</span> <span class="o">=</span> <span class="n">bts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">bts</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)]</span>
            <span class="n">bts</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Beat&#39;</span>
            <span class="n">toConcat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bts</span><span class="p">)</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Beat&#39;</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">toConcat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">offsets</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Offset&#39;</span>
        <span class="k">if</span> <span class="n">measures</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;Measure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;Measure&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offsets</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">col_names</span>
        <span class="k">return</span> <span class="n">ret</span></div>


    <span class="k">def</span> <span class="nf">_beats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of beat numbers for each part in the score.</span>

<span class="sd">        :return: A DataFrame where each column corresponds to a part in the score,</span>
<span class="sd">            and each row index is the offset of a beat. The values are the beat</span>
<span class="sd">            numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_beats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span><span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">beat</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_beats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_beats&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Score.midiPitches">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.midiPitches">[docs]</a>
    <span class="k">def</span> <span class="nf">midiPitches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multi_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of notes and rests as MIDI pitches.</span>

<span class="sd">        MIDI does not have a representation for rests, so -1 is used as a </span>
<span class="sd">        placeholder.</span>

<span class="sd">        :param multi_index: Boolean, default False. If True, the returned DataFrame </span>
<span class="sd">            will have a MultiIndex.</span>
<span class="sd">        :return: A DataFrame of notes and rests as MIDI pitches. Rests are </span>
<span class="sd">            represented as -1.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`kernNotes`</span>
<span class="sd">            Return a DataFrame of the notes and rests given in kern notation.</span>
<span class="sd">        :meth:`notes`</span>
<span class="sd">            Return a DataFrame of the notes and rests given in American Standard</span>
<span class="sd">            Pitch Notation</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.midiPitches()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;midiPitches&#39;</span><span class="p">,</span> <span class="n">multi_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">midiPitches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m21ObjectsNoTies</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">nr</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">nr</span><span class="o">.</span><span class="n">isRest</span> <span class="k">else</span> <span class="n">nr</span><span class="o">.</span><span class="n">pitch</span><span class="o">.</span><span class="n">midi</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multi_index</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">midiPitches</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">midiPitches</span> <span class="o">=</span> <span class="n">midiPitches</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">midiPitches</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.notes">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.notes">[docs]</a>
    <span class="k">def</span> <span class="nf">notes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combine_rests</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combine_unisons</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of the notes and rests given in American Standard Pitch</span>
<span class="sd">        Notation where middle C is C4. Rests are designated with the string &quot;r&quot;.</span>

<span class="sd">        If `combine_rests` is True (default), non-first consecutive rests will be</span>
<span class="sd">        removed, effectively combining consecutive rests in each voice.</span>
<span class="sd">        `combine_unisons` works the same way for consecutive attacks on the same</span>
<span class="sd">        pitch in a given voice, however, `combine_unisons` defaults to False.</span>

<span class="sd">        :param combine_rests: Boolean, default True. If True, non-first consecutive </span>
<span class="sd">            rests will be removed.</span>
<span class="sd">        :param combine_unisons: Boolean, default False. If True, consecutive attacks </span>
<span class="sd">            on the same pitch in a given voice will be combined.</span>
<span class="sd">        :return: A DataFrame of notes and rests in American Standard Pitch Notation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`kernNotes`</span>
<span class="sd">            Return a DataFrame of the notes and rests given in kern notation.</span>
<span class="sd">        :meth:`midiPitches`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.notes()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;notes&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m21ObjectsNoTies</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">noteRestHelper</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;notes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;notes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">combine_rests</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">combineRests</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">combine_unisons</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">combineUnisons</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Score.kernNotes">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.kernNotes">[docs]</a>
    <span class="k">def</span> <span class="nf">kernNotes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame of the notes and rests given in kern notation.</span>

<span class="sd">        This is not the same as creating a kern format of a score, but is an </span>
<span class="sd">        important step in that process.</span>

<span class="sd">        :return: A DataFrame of notes and rests in kern notation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth: `midiPitches`</span>
<span class="sd">        :meth:`notes`</span>
<span class="sd">            Return a DataFrame of the notes and rests given in American Standard</span>
<span class="sd">            Pitch Notation</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.kernNotes()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;kernNotes&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;kernNotes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span>
                <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">kernNRCHelper</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;kernNotes&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.nmats">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.nmats">[docs]</a>
    <span class="k">def</span> <span class="nf">nmats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_cdata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of DataFrames, one for each voice, with information </span>
<span class="sd">        about the notes and rests in that voice.</span>

<span class="sd">        Each DataFrame has the following columns:</span>

<span class="sd">        MEASURE  ONSET  DURATION  PART  MIDI  ONSET_SEC  OFFSET_SEC</span>

<span class="sd">        In the MIDI column, notes are represented </span>
<span class="sd">        with their MIDI pitch numbers (0 to 127), and rests are represented with -1s. </span>
<span class="sd">        The ONSET_SEC and OFFSET_SEC columns are taken from the audio analysis from </span>
<span class="sd">        the `json_path` file if one is given. The XML_IDs of each note or rest serve </span>
<span class="sd">        as the index for this DataFrame. If `include_cdata` is True and a `json_path` </span>
<span class="sd">        is provided, the cdata from the json file is included in the DataFrame.</span>

<span class="sd">        :param json_path: Optional path to a JSON file containing audio analysis data.</span>
<span class="sd">        :param include_cdata: Boolean, default False. If True and a `json_path` is </span>
<span class="sd">            provided, the cdata from the json file is included in the DataFrame.</span>
<span class="sd">        :return: A dictionary of DataFrames, one for each voice.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`fromJSON`</span>
<span class="sd">        :meth:`insertAudioAnalysis`</span>
<span class="sd">        :meth:`jsonCDATA`</span>
<span class="sd">        :meth:`xmlIDs`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/Mozart_K179_seg.krn&#39;)</span>
<span class="sd">            piece.nmats()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">json_path</span><span class="p">:</span>   <span class="c1"># user must pass a json_path if they want the cdata to be included</span>
            <span class="n">include_cdata</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;nmats&#39;</span><span class="p">,</span> <span class="n">json_path</span><span class="p">,</span> <span class="n">include_cdata</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">nmats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">included</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">dur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">(</span><span class="n">multi_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midiPitches</span><span class="p">(</span><span class="n">multi_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measures</span><span class="p">()</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmlIDs</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">json_path</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">json_path</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.json&#39;</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">fromJSON</span><span class="p">(</span><span class="n">json_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">json_path</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">json_path</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">githubURLtoRaw</span><span class="p">(</span><span class="n">json_path</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">col_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">,</span> <span class="s1">&#39;MIDI&#39;</span><span class="p">,</span> <span class="s1">&#39;DURATION&#39;</span><span class="p">)</span>
                    <span class="c1"># sometimes these files only have two columns instead of three</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">col_names</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;MIDI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;MIDI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_midi</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;Int16&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">ms</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">((</span><span class="n">ms</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">partName</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">meas</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">midi</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="n">onsetBeat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">midi</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">midi</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
                <span class="n">durBeat</span> <span class="o">=</span> <span class="n">dur</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">partName</span><span class="p">,</span> <span class="n">midi</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
                <span class="n">xmlID</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span> <span class="o">==</span> <span class="s1">&#39;csv&#39;</span><span class="p">:</span>
                    <span class="n">csv_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;tony_csv&#39;</span><span class="p">]</span>
                    <span class="n">csv_data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">onsetSec</span> <span class="o">=</span> <span class="n">csv_data</span><span class="p">[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">]</span>
                    <span class="n">offsetSec</span> <span class="o">=</span> <span class="n">csv_data</span><span class="p">[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">csv_data</span><span class="p">[</span><span class="s1">&#39;DURATION&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">onsetSec</span> <span class="o">=</span> <span class="n">onsetBeat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># This is overwritten by midiTicks function</span>
                    <span class="n">offsetSec</span> <span class="o">=</span> <span class="n">onsetBeat</span> <span class="o">+</span> <span class="n">durBeat</span>  <span class="c1"># This is overwritten by midiTicks function</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">meas</span><span class="p">,</span> <span class="n">onsetBeat</span><span class="p">,</span> <span class="n">durBeat</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">midi</span><span class="p">,</span>
                               <span class="n">onsetSec</span><span class="p">,</span> <span class="n">offsetSec</span><span class="p">,</span> <span class="n">xmlID</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MEASURE&#39;</span><span class="p">,</span> <span class="s1">&#39;ONSET&#39;</span><span class="p">,</span> <span class="s1">&#39;DURATION&#39;</span><span class="p">,</span> <span class="s1">&#39;PART&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;MIDI&#39;</span><span class="p">,</span> <span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">,</span> <span class="s1">&#39;OFFSET_SEC&#39;</span><span class="p">,</span> <span class="s1">&#39;XML_ID&#39;</span><span class="p">]</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;MEASURE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;MEASURE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
                <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;XML_ID&#39;</span><span class="p">)</span>

                <span class="c1"># Remove rows where MIDI == -1.0</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;MIDI&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span>

                <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midi_ticks_durations</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">json_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1"># add json data if a json_path is provided</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="p">:]</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">*** Warning ***</span><span class="se">\n\n</span><span class="s1">The json data has more observations than there are notes in this part so the data was truncated.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="p">:]</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">*** Warning ***</span><span class="se">\n\n</span><span class="s1">There are more events than there are json records in this part.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
                    <span class="k">if</span> <span class="n">json_path</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.json&#39;</span><span class="p">):</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">df</span><span class="p">,</span> <span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">included</span><span class="p">[</span><span class="n">partName</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                    <span class="k">elif</span> <span class="n">json_path</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">):</span>
                        <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">,</span> <span class="s1">&#39;MIDI&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">,</span> <span class="s1">&#39;MIDI&#39;</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="s1">&#39;DURATION&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                            <span class="n">df</span><span class="o">.</span><span class="n">OFFSET_SEC</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">ONSET_SEC</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;DURATION&#39;</span><span class="p">]</span>
                        <span class="n">included</span><span class="p">[</span><span class="n">partName</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="n">nmats</span><span class="p">[</span><span class="n">partName</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;nmats&#39;</span><span class="p">,</span> <span class="n">json_path</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nmats</span>
            <span class="k">if</span> <span class="n">json_path</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[(</span><span class="s1">&#39;nmats&#39;</span><span class="p">,</span> <span class="n">json_path</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">included</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.pianoRoll">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.pianoRoll">[docs]</a>
    <span class="k">def</span> <span class="nf">pianoRoll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a MIDI piano roll. This representation of a score plots midi pitches</span>
<span class="sd">        on the y-axis (rows) and time on the x-axis (columns). Midi pitches are given</span>
<span class="sd">        as integers from 0 to 127 inclusive, and time is given in quarter notes counting</span>
<span class="sd">        up from the beginning of the piece. At any given time in the piece (column), all</span>
<span class="sd">        the sounding pitches are shown as 1s in the corresponding rows. There is no</span>
<span class="sd">        midi representation of rests so these are not shown in the pianoRoll. Similarly,</span>
<span class="sd">        in this representation you can&#39;t tell if a single voice is sounding a given note,</span>
<span class="sd">        of if multiple voices are sounding the same note. The end result looks like a</span>
<span class="sd">        player piano roll but 1s are used instead of holes. This method is primarily</span>
<span class="sd">        used as an intermediate step in the construction of a mask.</span>

<span class="sd">        Note: There are 128 possible MIDI pitches.</span>

<span class="sd">        :return: A DataFrame representing the MIDI piano roll. Each row corresponds </span>
<span class="sd">            to a MIDI pitch (0 to 127), and each column corresponds to an offset in </span>
<span class="sd">            the score. The values are 1 for a note onset and 0 otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`mask`</span>
<span class="sd">        :meth:`sampled`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.pianoRoll()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;pianoRoll&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">mp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midiPitches</span><span class="p">()</span>
            <span class="c1"># remove non-last offset repeats and forward-fill</span>
            <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">[</span><span class="o">~</span><span class="n">mp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
            <span class="n">pianoRoll</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">mp</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pitch</span> <span class="ow">in</span> <span class="n">mp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">offset</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">pitch</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pianoRoll</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">pitch</span><span class="p">,</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">pianoRoll</span> <span class="o">=</span> <span class="n">pianoRoll</span><span class="o">.</span><span class="n">infer_objects</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;pianoRoll&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pianoRoll</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;pianoRoll&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.sampled">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.sampled">[docs]</a>
    <span class="k">def</span> <span class="nf">sampled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bpm</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="mi">24</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample the score according to the given beats per minute (bpm) and the </span>
<span class="sd">        desired observations per second (obs). This method is primarily used as an</span>
<span class="sd">        intermediate step in the construction of a mask. It builds on the pianoRoll</span>
<span class="sd">        by sampling the time axis (columns) at the desired rate. The result is a</span>
<span class="sd">        DataFrame where each row corresponds to a MIDI pitch (0 to 127), and each</span>
<span class="sd">        column corresponds to a timepoint in the sampled score. The difference</span>
<span class="sd">        between this and the pianoRoll is that the columns are sampled at a regular</span>
<span class="sd">        time intervals, rather than at each new event as they are in the pianoRoll.</span>

<span class="sd">        :param bpm: Integer, default 60. The beats per minute to use for sampling.</span>
<span class="sd">        :param obs: Integer, default 24. The desired observations per second.</span>
<span class="sd">        :return: A DataFrame representing the sampled score. Each row corresponds </span>
<span class="sd">            to a MIDI pitch (0 to 127), and each column corresponds to a timepoint </span>
<span class="sd">            in the sampled score. The values are 1 for a note onset and 0 otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`mask`</span>
<span class="sd">        :meth:`pianoRoll`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.sampled()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sampled&#39;</span><span class="p">,</span> <span class="n">bpm</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="mi">60</span><span class="o">/</span><span class="n">bpm</span> <span class="o">*</span> <span class="n">obs</span>
            <span class="n">timepoints</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span>
                <span class="p">[</span><span class="n">t</span><span class="o">/</span><span class="n">slices</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">highestTime</span> <span class="o">*</span> <span class="n">slices</span><span class="p">))])</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pianoRoll</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pr</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">timepoints</span> <span class="k">else</span> <span class="n">timepoints</span><span class="o">.</span><span class="n">asof</span><span class="p">(</span>
                <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">pr</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">~</span><span class="n">pr</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)]</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">T</span>
            <span class="n">sampled</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">timepoints</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampled</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.mask">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.mask">[docs]</a>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winms</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">bpm</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">aFreq</span><span class="o">=</span><span class="mi">440</span><span class="p">,</span> <span class="n">base_note</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tuning_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="mi">24</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a mask from the sampled piano roll using width and harmonics. This</span>
<span class="sd">        builds on the intermediate representations of the pianoRoll and sampled</span>
<span class="sd">        methods. The sampled method already put the x-axis (columns) in regular</span>
<span class="sd">        time intervals. The mask keeps these columns and then alters the y-axis (rows)</span>
<span class="sd">        into frequency bins. The number of bins is determined by the winms and sample_rate</span>
<span class="sd">        values, and is equal to some power of 2 plus 1. The frequency bins serve to &quot;blur&quot;</span>
<span class="sd">        the sampled pitch data that we expect from the score. This allows us to detect</span>
<span class="sd">        real performed sounds in audio recordings that are likely slightly above or below</span>
<span class="sd">        the precise notated pitches. The mask is what allows pyAMPACT to connect</span>
<span class="sd">        symbolic events in a score to observed sounds in an audio recording. Increasing</span>
<span class="sd">        the `num_harmonics` will also include that many harmonics of a notated score</span>
<span class="sd">        pitch in the mask. Note that the first harmonic is the fundamental frequency</span>
<span class="sd">        which is why the `num_harmonics` parameter defaults to 1. The `width` parameter</span>
<span class="sd">        controls how broad or &quot;blurry&quot; the mask is compared to the notated score.</span>

<span class="sd">        :param winms: Integer, default 100. The window size in milliseconds.</span>
<span class="sd">        :param sample_rate: Integer, default 2000. The sample rate in Hz.</span>
<span class="sd">        :param num_harmonics: Integer, default 1. The number of harmonics to use.</span>
<span class="sd">        :param width: Integer, default 0. The width of the mask.</span>
<span class="sd">        :param bpm: Integer, default 60. The beats per minute to use for sampling.</span>
<span class="sd">        :param aFreq: Integer, default 440. The frequency of A4 in Hz.</span>
<span class="sd">        :param base_note: Integer, default 0. The base MIDI note to use.</span>
<span class="sd">        :param tuning_factor: Float, default 1. The tuning factor to use.</span>
<span class="sd">        :param obs: Integer, default 24. The desired observations per second.</span>
<span class="sd">        :return: A DataFrame representing the mask. Each row corresponds to a </span>
<span class="sd">            frequency bin, and each column corresponds to a timepoint in the </span>
<span class="sd">            sampled score. The values are 1 for a note onset and 0 otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`pianoRoll`</span>
<span class="sd">        :meth:`sampled`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.mask()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="n">winms</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="p">,</span>
               <span class="n">width</span><span class="p">,</span> <span class="n">bpm</span><span class="p">,</span> <span class="n">aFreq</span><span class="p">,</span> <span class="n">base_note</span><span class="p">,</span> <span class="n">tuning_factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">width_semitone_factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">((</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span>
            <span class="n">sampled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span><span class="p">(</span><span class="n">bpm</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">**</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">winms</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span>
                <span class="n">num_rows</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="n">sampled</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">infer_objects</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">fftlen</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">winms</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span>
                              <span class="n">sample_rate</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_note</span><span class="p">,</span> <span class="n">sampled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">note</span> <span class="o">=</span> <span class="n">base_note</span> <span class="o">+</span> <span class="n">row</span>
                <span class="c1"># MIDI note to Hz: MIDI 69 = 440 Hz = A4</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">tuning_factor</span> <span class="o">*</span> \
                    <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">note</span> <span class="o">/</span> <span class="mi">12</span><span class="p">))</span> <span class="o">*</span> <span class="n">aFreq</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">69</span> <span class="o">/</span> <span class="mi">12</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">sampled</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mcol</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_rows</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">harm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_harmonics</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">minbin</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
                            <span class="n">harm</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">/</span> <span class="n">width_semitone_factor</span> <span class="o">/</span> <span class="n">sample_rate</span> <span class="o">*</span> <span class="n">fftlen</span><span class="p">)</span>
                        <span class="n">maxbin</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                            <span class="n">harm</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">width_semitone_factor</span> <span class="o">/</span> <span class="n">sample_rate</span> <span class="o">*</span> <span class="n">fftlen</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">minbin</span> <span class="o">&lt;=</span> <span class="n">num_rows</span><span class="p">:</span>
                            <span class="n">maxbin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxbin</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">)</span>
                            <span class="n">mcol</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">minbin</span><span class="p">:</span> <span class="n">maxbin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">mask</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">sampled</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.jsonCDATA">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.jsonCDATA">[docs]</a>
    <span class="k">def</span> <span class="nf">jsonCDATA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of pandas DataFrames, one for each voice. These </span>
<span class="sd">        DataFrames contain the cdata from the JSON file designated in `json_path` </span>
<span class="sd">        with each nested key in the JSON object becoming a column name in the </span>
<span class="sd">        DataFrame. The outermost keys of the JSON cdata will become the &quot;absolute&quot; </span>
<span class="sd">        column. While the columns are different, there are as many rows in these </span>
<span class="sd">        DataFrames as there are in those of the nmats DataFrames for each voice.</span>

<span class="sd">        :param json_path: Path to a JSON file containing cdata.</span>
<span class="sd">        :return: A dictionary of pandas DataFrames, one for each voice.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`fromJSON`</span>
<span class="sd">        :meth:`insertAudioAnalysis`</span>
<span class="sd">        :meth:`nmats`</span>
<span class="sd">        :meth:`xmlIDs`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;./test_files/CloseToYou.mei.xml&#39;)</span>
<span class="sd">            piece.jsonCDATA(json_path=&#39;./test_files/CloseToYou.json&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;jsonCDATA&#39;</span><span class="p">,</span> <span class="n">json_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">nmats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmats</span><span class="p">(</span><span class="n">json_path</span><span class="o">=</span><span class="n">json_path</span><span class="p">,</span> <span class="n">include_cdata</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">,</span> <span class="o">*</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nmats</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">7</span><span class="p">:]]</span>
            <span class="n">post</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">partName</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">nmats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">res</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">:</span> <span class="s1">&#39;absolute&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">post</span><span class="p">[</span><span class="n">partName</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">post</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Score.insertAudioAnalysis">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.insertAudioAnalysis">[docs]</a>
    <span class="k">def</span> <span class="nf">insertAudioAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mimetype</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mei_tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a &lt;performance&gt; element into the MEI score given the analysis data </span>
<span class="sd">        (`data`) in the format of a json file or an nmat dictionary with audio data</span>
<span class="sd">        already included. If the original score is not an MEI file, a new MEI file</span>
<span class="sd">        will be created and used. The JSON data will be extracted via the `.nmats()`</span>
<span class="sd">        method. If provided, the `mimetype` and `target` get passed as</span>
<span class="sd">        attributes to the &lt;avFile&gt; element. The performance element will nest</span>
<span class="sd">        the DataFrame data in the &lt;performance&gt; element as a child of  &lt;music&gt;</span>
<span class="sd">        and a sibling of &lt;body&gt;. A new file will be saved to the </span>
<span class="sd">        `output_filename` in the current working directory.</span>

<span class="sd">        .. parsed-literal::</span>

<span class="sd">            &lt;music&gt;</span>
<span class="sd">                &lt;performance xml:id=&quot;pyAMPACT-1&quot;&gt;</span>
<span class="sd">                    &lt;recording xml:id=&quot;pyAMPACT-2&quot;&gt;</span>
<span class="sd">                        &lt;avFile mimetype=&quot;audio/aiff&quot; target=&quot;song.wav&quot; xml:id=&quot;pyAMPACT-3&quot; /&gt;</span>
<span class="sd">                        &lt;when absolute=&quot;00:00:12:428&quot; xml:id=&quot;pyAMPACT-4&quot; data=&quot;#note_1&quot;&gt;</span>
<span class="sd">                            &lt;extData xml:id=&quot;pyAMPACT-5&quot;&gt;</span>
<span class="sd">                                &lt;![CDATA[&gt;</span>
<span class="sd">                                    {&quot;ppitch&quot;:221.30926295063591, &quot;jitter&quot;:0.7427361, ...}</span>
<span class="sd">                                ]]&gt;</span>
<span class="sd">                            &lt;/extData&gt;</span>
<span class="sd">                        &lt;/when&gt;</span>
<span class="sd">                        &lt;when absolute=&quot;00:00:12:765&quot; xml:id=&quot;pyAMPACT-6&quot; data=&quot;#note_2&quot;&gt;</span>
<span class="sd">                        ...</span>
<span class="sd">                    &lt;/recording&gt;</span>
<span class="sd">                &lt;/performance&gt;</span>
<span class="sd">                &lt;body&gt;</span>
<span class="sd">                    ...</span>
<span class="sd">                &lt;/body&gt;</span>
<span class="sd">            &lt;/music&gt;</span>

<span class="sd">        :param output_filename: The name of the output file.</span>
<span class="sd">        :param data: Path to a JSON file containing analysis data or an nmats dictionary.</span>
<span class="sd">        :param mimetype: Optional MIME type to be set as an attribute to the &lt;avFile&gt; </span>
<span class="sd">            element.</span>
<span class="sd">        :param target: Optional target to be set as an attribute to the &lt;avFile&gt; </span>
<span class="sd">            element.</span>
<span class="sd">        :param mei_tree: Optional ElementTree object to use as the base for the new file.</span>
<span class="sd">            If this is not passed, then the original MEI file is used if the Score</span>
<span class="sd">            is an MEI file. Otherwise a new MEI file is created with .toMEI().</span>
<span class="sd">        :return: None but a new file is written</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`nmats`</span>
<span class="sd">        :meth:`toKern`</span>
<span class="sd">        :meth:`toMEI`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;./test_files/CloseToYou.mei.xml&#39;)</span>
<span class="sd">            piece.insertAudioAnalysis(output_filename=&#39;newfile.mei.xml&#39;</span>
<span class="sd">                data=&#39;./test_files/CloseToYou.json&#39;,</span>
<span class="sd">                mimetype=&#39;audio/aiff&#39;,</span>
<span class="sd">                target=&#39;Close to You vocals.wav&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">performance</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;performance&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
        <span class="n">recording</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">performance</span><span class="p">,</span> <span class="s1">&#39;recording&#39;</span><span class="p">,</span> <span class="p">{</span>
                                  <span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
        <span class="n">avFile</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">recording</span><span class="p">,</span> <span class="s1">&#39;avFile&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
        <span class="k">if</span> <span class="n">mimetype</span><span class="p">:</span>
            <span class="n">avFile</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;mimetype&#39;</span><span class="p">,</span> <span class="n">mimetype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">avFile</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>   <span class="c1"># this is the case for nmats</span>
            <span class="n">jsonCDATA</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">for</span> <span class="n">part_name</span><span class="p">,</span> <span class="n">part_df</span> <span class="ow">in</span> <span class="n">jsonCDATA</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ndx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">when</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">recording</span><span class="p">,</span> <span class="s1">&#39;when&#39;</span><span class="p">,</span> <span class="p">{</span>
                                         <span class="s1">&#39;absolute&#39;</span><span class="p">:</span> <span class="n">part_df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">ndx</span><span class="p">,</span> <span class="s1">&#39;ONSET_SEC&#39;</span><span class="p">],</span> <span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;#</span><span class="si">{</span><span class="n">ndx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
                    <span class="n">extData</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                        <span class="n">when</span><span class="p">,</span> <span class="s1">&#39;extData&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
                    <span class="n">extData</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39; &lt;![CDATA[ </span><span class="si">{</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">part_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span><span class="si">}</span><span class="s1"> ]]&gt; &#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jsonCDATA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jsonCDATA</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mei_tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">toMEI</span><span class="p">()</span>   <span class="c1"># this will save the MEI tree to self._meiTree</span>
            <span class="n">mei_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span>
        <span class="n">musicEl</span> <span class="o">=</span> <span class="n">mei_tree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.//music&#39;</span><span class="p">)</span>
        <span class="n">musicEl</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">performance</span><span class="p">)</span>
        <span class="c1"># if not output_path.endswith(&#39;.mei.xml&#39;):</span>
        <span class="c1">#     output_path = output_path.split(&#39;.&#39;, 1)[0] + &#39;.mei.xml&#39;</span>

        <span class="n">indentMEI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span><span class="o">.</span><span class="n">getroot</span><span class="p">())</span>
        <span class="c1"># get header/xml descriptor from original file</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.mei.xml&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.mei&#39;</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;&lt;mei &#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">convert_attribs_to_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span><span class="o">.</span><span class="n">getroot</span><span class="p">())</span>
            <span class="n">xml_string</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span><span class="o">.</span><span class="n">getroot</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;unicode&#39;</span><span class="p">)</span>
            <span class="n">score_lines</span> <span class="o">=</span> <span class="n">xml_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">score_lines</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;&lt;mei &#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span><span class="o">.</span><span class="n">getroot</span><span class="p">())</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">f</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;unicode&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.show">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.show">[docs]</a>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a VerovioHumdrumViewer link to the score in between the `start` and</span>
<span class="sd">        `stop` measures (inclusive).</span>

<span class="sd">        :param start: Optional integer representing the starting measure. If `start` </span>
<span class="sd">            is greater than `stop`, they will be swapped.</span>
<span class="sd">        :param stop: Optional integer representing the last measure.</span>
<span class="sd">        :return: None but a url is printed out</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`toKern`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/M025_00_01a_a.krn&#39;)</span>
<span class="sd">            piece.show(5, 10)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span><span class="p">,</span> <span class="n">start</span>
        <span class="n">tk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toKern</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[:</span><span class="n">tk</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">=&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">headerColCount</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">startIndex</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fromStart</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[</span><span class="n">startIndex</span><span class="p">:]</span>
            <span class="n">fromStartColCount</span> <span class="o">=</span> <span class="n">fromStart</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># add the last divisi line to try to get the column count right</span>
            <span class="k">if</span> <span class="n">fromStartColCount</span> <span class="o">&gt;</span> <span class="n">headerColCount</span><span class="p">:</span>
                <span class="n">divisi</span> <span class="o">=</span> <span class="p">[</span><span class="n">fromStart</span><span class="p">]</span>
                <span class="n">firstLines</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[:</span><span class="n">startIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">firstLines</span><span class="p">):</span>
                    <span class="k">if</span> <span class="s1">&#39;*^&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                        <span class="n">divisi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">fromStartColCount</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">headerColCount</span><span class="p">:</span>
                            <span class="k">break</span>
                <span class="n">fromStart</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">divisi</span><span class="p">))</span>
            <span class="n">tk</span> <span class="o">=</span> <span class="n">header</span> <span class="o">+</span> <span class="n">fromStart</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measures</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">tk</span> <span class="o">=</span> <span class="n">tk</span><span class="p">[:</span><span class="n">tk</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;=</span><span class="si">{</span><span class="n">stop</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)]</span>
        <span class="n">encoded</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&#39;&#39;</span><span class="se">\n</span><span class="s1">At </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span><span class="si">}</span><span class="s1"> characters, this excerpt is too long to be passed in a url. Instead,</span><span class="se">\</span>
<span class="s1">            </span><span class="se">\n</span><span class="s1"> to see the whole score you can run .toKern(&quot;your_file_name&quot;), then drag and drop</span><span class="se">\</span>
<span class="s1">            </span><span class="se">\n</span><span class="s1">that file to VHV: https://verovio.humdrum.org/&#39;&#39;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;https://verovio.humdrum.org/?t=</span><span class="si">{</span><span class="n">encoded</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Score.toKern">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.toKern">[docs]</a>
    <span class="k">def</span> <span class="nf">toKern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">lyrics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dynamics</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a kern representation of the score. If no `path_name` variable is</span>
<span class="sd">        passed, then returns a pandas DataFrame of the kern representation. </span>
<span class="sd">        Otherwise a file is created or overwritten at the `path_name` path. If </span>
<span class="sd">        path_name does not end in &#39;.krn&#39; then this file extension will be added </span>
<span class="sd">        to the path. If `lyrics` is `True` (default) then the lyrics for each part </span>
<span class="sd">        will be added to the output, if there are lyrics. The same applies to </span>
<span class="sd">        `dynamics`.</span>

<span class="sd">        :param path_name: Optional string representing the path to save the kern </span>
<span class="sd">            file.</span>
<span class="sd">        :param data: Optional string representing the data to be converted to kern </span>
<span class="sd">            format.</span>
<span class="sd">        :param lyrics: Boolean, default True. If True, lyrics for each part will </span>
<span class="sd">            be added.</span>
<span class="sd">        :param dynamics: Boolean, default True. If True, dynamics for each part </span>
<span class="sd">            will be added.</span>
<span class="sd">        :return: String of new kern score if no `path_name` is given, or None if</span>
<span class="sd">            writing the new kern file to the location of `path_name`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`show`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            # create a kern file from a different symbolic notation file</span>
<span class="sd">            piece = Score(&#39;https://github.com/pyampact/pyAMPACTtutorials/blob/main/test_files/K179.xml&#39;)</span>
<span class="sd">            piece.toKern()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;toKern&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measures</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;=</span><span class="si">{</span><span class="n">cell</span><span class="si">}</span><span class="s1">-&#39;</span> <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;=</span><span class="si">{</span><span class="n">cell</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernNotes</span><span class="p">()</span>
            <span class="n">isMI</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span>
            <span class="n">includeLyrics</span><span class="p">,</span> <span class="n">includeDynamics</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">lyrics</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lyrics</span><span class="p">()</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">includeLyrics</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">lyr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lyrics</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">isMI</span><span class="p">:</span>
                    <span class="n">lyr</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">lyr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lyr</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">dynamics</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">()</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">includeDynamics</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">isMI</span><span class="p">:</span>
                    <span class="n">dyn</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">dyn</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dyn</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
            <span class="n">_cols</span><span class="p">,</span> <span class="n">firstTokens</span><span class="p">,</span> <span class="n">partNumbers</span><span class="p">,</span> <span class="n">staves</span><span class="p">,</span> <span class="n">instruments</span><span class="p">,</span> <span class="n">partNames</span><span class="p">,</span> <span class="n">shortNames</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="c1"># reverse column order because kern order is lowest staves on the left</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                <span class="n">partNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                    <span class="n">col</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partNames</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">firstTokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;**kern&#39;</span><span class="p">)</span>
                <span class="n">partNumbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*part</span><span class="si">{</span><span class="n">partNum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">staves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*staff</span><span class="si">{</span><span class="n">partNum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">instruments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;*Ivox&#39;</span><span class="p">)</span>
                <span class="n">partNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*I&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">shortNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;*I&#39;</span><span class="si">{</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">includeLyrics</span> <span class="ow">and</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">lyr</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">lyrCol</span> <span class="o">=</span> <span class="n">lyr</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">lyrCol</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Text_&#39;</span> <span class="o">+</span> <span class="n">lyrCol</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lyrCol</span><span class="p">)</span>
                    <span class="n">firstTokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;**text&#39;</span><span class="p">)</span>
                    <span class="n">partNumbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*part</span><span class="si">{</span><span class="n">partNum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">staves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*staff</span><span class="si">{</span><span class="n">partNum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">includeDynamics</span> <span class="ow">and</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">dyn</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">dynCol</span> <span class="o">=</span> <span class="n">dyn</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">dynCol</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Dynam_&#39;</span> <span class="o">+</span> <span class="n">dynCol</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dynCol</span><span class="p">)</span>
                    <span class="n">firstTokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;**dynam&#39;</span><span class="p">)</span>
                    <span class="n">partNumbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*part</span><span class="si">{</span><span class="n">partNum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">staves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*staff</span><span class="si">{</span><span class="n">partNum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">events</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">_cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_barlines</span><span class="p">()</span>
            <span class="n">ba</span> <span class="o">=</span> <span class="n">ba</span><span class="p">[</span><span class="n">ba</span> <span class="o">!=</span> <span class="s1">&#39;regular&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="p">{</span><span class="s1">&#39;double&#39;</span><span class="p">:</span> <span class="s1">&#39;||&#39;</span><span class="p">,</span> <span class="s1">&#39;final&#39;</span><span class="p">:</span> <span class="s1">&#39;==&#39;</span><span class="p">})</span>
            <span class="n">ba</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">highestTime</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="s1">&#39;==&#39;</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">cdata</span> <span class="o">=</span> <span class="n">fromJSON</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">cdata</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">cdata</span><span class="p">)]</span>
                <span class="n">firstTokens</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;**</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cdata</span><span class="o">.</span><span class="n">columns</span><span class="p">])</span>
                <span class="n">addTieBreakers</span><span class="p">((</span><span class="n">events</span><span class="p">,</span> <span class="n">cdata</span><span class="p">))</span>
                <span class="n">events</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">events</span><span class="p">,</span> <span class="n">cdata</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">me</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">me</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ba</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ba</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">me</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">ba</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_divisiStarts&#39;</span><span class="p">]</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
            <span class="n">de</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_divisiEnds&#39;</span><span class="p">]</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
            <span class="n">clefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clefs</span><span class="p">()</span>
            <span class="n">clefs</span> <span class="o">=</span> <span class="n">clefs</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="s1">&#39;*M&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeSignatures</span><span class="p">()</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keySignatures</span><span class="p">()</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
            <span class="n">partTokens</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">firstTokens</span><span class="p">,</span> <span class="n">partNumbers</span><span class="p">,</span> <span class="n">staves</span><span class="p">,</span> <span class="n">instruments</span><span class="p">,</span> <span class="n">partNames</span><span class="p">,</span> <span class="n">shortNames</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;*-&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">)],</span>
                                      <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="n">highestTime</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
            <span class="n">partTokens</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="n">partTokens</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">me</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">clefs</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">ba</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">addTieBreakers</span><span class="p">(</span><span class="n">to_concat</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">to_concat</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">colName</span> <span class="ow">in</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;__&#39;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]:</span>
                <span class="n">divStarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">colName</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*^&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">divEnds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">colName</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*v&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">colIndex</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">colName</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_ii</span><span class="p">,</span> <span class="n">startRow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">divStarts</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_ii</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># delete everying in target cols up to first divisi</span>
                        <span class="n">body</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">startRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># delete everything from the last divisi consolidation to this new divisi</span>
                        <span class="n">body</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">divEnds</span><span class="p">[</span><span class="n">_ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                  <span class="mi">1</span><span class="p">:</span> <span class="n">startRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="c1"># delete everything in target cols after final consolidation</span>
                    <span class="k">if</span> <span class="n">_ii</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">divStarts</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_ii</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">divEnds</span><span class="p">):</span>
                        <span class="n">body</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">divEnds</span><span class="p">[</span><span class="n">_ii</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:,</span> <span class="n">colIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">kernHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">row</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">kernFooter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span><span class="p">),))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.krn&#39;</span><span class="p">):</span>
                <span class="n">path_name</span> <span class="o">+=</span> <span class="s1">&#39;.krn&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="nf">_meiStack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DataFrame stacked to be a multi-indexed series containing the</span>
<span class="sd">        score elements to be processed into the MEI format. This is used  for</span>
<span class="sd">        MEI output. Only used internally.</span>

<span class="sd">        :return: A Series of the score in MEI format</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`toMEI`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_meiStack&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="c1"># assign column names in format (partNumber, voiceNumer) with no splitting up of chords</span>
            <span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span><span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">clefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m21Clefs</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ksigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keySignatures</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tsigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeSignatures</span><span class="p">(</span><span class="n">ratio</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">mi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">clefs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Staff&#39;</span><span class="p">,</span> <span class="s1">&#39;Layer&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">staffInfo</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">clefs</span><span class="p">,</span> <span class="n">ksigs</span><span class="p">,</span> <span class="n">tsigs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="mf">0.0</span> <span class="ow">in</span> <span class="n">staffInfo</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                    <span class="n">staffInfo</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">staffInfo</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">staffInfo</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">9</span><span class="p">]])</span>
                <span class="n">staffInfo</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">mi</span>

            <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measures</span><span class="p">(</span><span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">me</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">partName</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">ei</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">mi</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">mi</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Measure&#39;</span>
                <span class="n">addTieBreakers</span><span class="p">((</span><span class="n">ei</span><span class="p">,</span> <span class="n">mi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">partName</span> <span class="ow">in</span> <span class="n">clefs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">ci</span> <span class="o">=</span> <span class="n">clefs</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">partName</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                    <span class="n">ki</span> <span class="o">=</span> <span class="n">ksigs</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">partName</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                    <span class="n">ti</span> <span class="o">=</span> <span class="n">tsigs</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">partName</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                    <span class="n">ei</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">ci</span><span class="p">,</span> <span class="n">ki</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">ei</span><span class="p">))</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
                <span class="c1"># force measures to come before any grace notes. # TODO: check case of nachschlag grace notes</span>
                <span class="n">mi</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">mi</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">set_levels</span><span class="p">([</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">ei</span><span class="p">,</span> <span class="n">mi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">part</span><span class="o">.</span><span class="n">Measure</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">Measure</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Measure&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">droplevel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">future_stack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_meiStack&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="s1">&#39;_meiStack&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_coreMEIElements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span>
            <span class="s1">&#39;mei&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xmlns&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.music-encoding.org/ns/mei&#39;</span><span class="p">,</span> <span class="s1">&#39;meiversion&#39;</span><span class="p">:</span> <span class="s1">&#39;5.1-dev&#39;</span><span class="p">})</span>

        <span class="n">meiHead</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;meiHead&#39;</span><span class="p">)</span>
        <span class="n">fileDesc</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">meiHead</span><span class="p">,</span> <span class="s1">&#39;fileDesc&#39;</span><span class="p">)</span>
        <span class="n">titleStmt</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">fileDesc</span><span class="p">,</span> <span class="s1">&#39;titleStmt&#39;</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">titleStmt</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span>
        <span class="n">composer</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">titleStmt</span><span class="p">,</span> <span class="s1">&#39;composer&#39;</span><span class="p">)</span>
        <span class="n">composer</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;composer&#39;</span><span class="p">]</span>
        <span class="n">pubStmt</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">fileDesc</span><span class="p">,</span> <span class="s1">&#39;pubStmt&#39;</span><span class="p">)</span>
        <span class="n">unpub</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">pubStmt</span><span class="p">,</span> <span class="s1">&#39;unpub&#39;</span><span class="p">)</span>
        <span class="n">unpub</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;This mei file was converted from a .</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fileExtension</span><span class="si">}</span><span class="s1"> file by pyAMPACT&#39;</span>
        <span class="n">music</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;music&#39;</span><span class="p">)</span>
        <span class="c1"># insert performance element here</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">music</span><span class="p">,</span> <span class="s1">&#39;body&#39;</span><span class="p">)</span>
        <span class="n">mdiv</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s1">&#39;mdiv&#39;</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">mdiv</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">)</span>
        <span class="n">section</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="s1">&#39;section&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insertScoreDef</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>

<div class="viewcode-block" id="Score.toMEI">
<a class="viewcode-back" href="../../symbolic.html#pyampact.symbolic.Score.toMEI">[docs]</a>
    <span class="k">def</span> <span class="nf">toMEI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">indentation</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dfs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_tag</span><span class="o">=</span><span class="s1">&#39;annot&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write or return an MEI score optionally including analysis data.</span>

<span class="sd">        If no `file_name` is passed then returns a string of the MEI representation.</span>
<span class="sd">        Otherwise a file called `file_name` is created or overwritten in the current working</span>
<span class="sd">        directory. If `file_name` does not end in &#39;.mei.xml&#39; or &#39;.mei&#39;, then the `.mei.xml`</span>
<span class="sd">        file extension will be added to the `file_name`.</span>

<span class="sd">        :param file_name: Optional string representing the name to save the new</span>
<span class="sd">            MEI file to the current working directory.</span>
<span class="sd">        :param data: Optional string of the path of score data in json format to</span>
<span class="sd">            be added to the the new mei file.</span>
<span class="sd">        :param start: Optional integer representing the starting measure. If `start`</span>
<span class="sd">            is greater than `stop`, they will be swapped.</span>
<span class="sd">        :param stop: Optional integer representing the last measure.</span>
<span class="sd">        :param dfs: Optional dictionary of pandas DataFrames to be added to the</span>
<span class="sd">            new MEI file. The keys of the dictionary will be used as the `@type`</span>
<span class="sd">            attribute of the `analysis_tag` parameter element.</span>
<span class="sd">        :param analysis_tag: Optional string representing the name of the tag to</span>
<span class="sd">            be used for the analysis data.</span>
<span class="sd">        :return: String of new MEI score if no `file_name` is given, or None if</span>
<span class="sd">            writing the new MEI file to the current working directory.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`toKern`</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            # create an MEI file from a different symbolic notation file</span>
<span class="sd">            piece = Score(&#39;kerntest.krn&#39;)</span>
<span class="sd">            piece.toMEI(file_name=&#39;meiFile.mei.xml&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;toMEI&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;analysis&#39;</span><span class="p">:</span> <span class="n">dfs</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coreMEIElements</span><span class="p">()</span>
            <span class="n">section</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.//section&#39;</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meiStack</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span><span class="p">,</span> <span class="n">start</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span><span class="n">stop</span><span class="p">]</span>
            <span class="n">uniqueStaves</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">uniqueLayers</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">measure</span> <span class="ow">in</span> <span class="n">stack</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="n">meas_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                    <span class="n">section</span><span class="p">,</span> <span class="s1">&#39;measure&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">measure</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">staff</span> <span class="ow">in</span> <span class="n">uniqueStaves</span><span class="p">:</span>
                    <span class="n">staff_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                        <span class="n">meas_el</span><span class="p">,</span> <span class="s1">&#39;staff&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">staff</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
                    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">uniqueLayers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">measure</span><span class="p">,</span> <span class="n">staff</span><span class="p">,</span> <span class="n">layer</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stack</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">layer_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                            <span class="n">staff_el</span><span class="p">,</span> <span class="s1">&#39;layer&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
                        <span class="n">parent</span> <span class="o">=</span> <span class="n">layer_el</span>
                        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">stack</span><span class="o">.</span><span class="n">loc</span><span class="p">[[(</span><span class="n">measure</span><span class="p">,</span> <span class="n">staff</span><span class="p">,</span> <span class="n">layer</span><span class="p">)]]</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;beams&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beamsList</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beamsList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
                                <span class="n">parent</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                                    <span class="n">layer_el</span><span class="p">,</span> <span class="s1">&#39;beam&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;isNote&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">isNote</span><span class="p">:</span>
                                <span class="n">addMEINote</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;isRest&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">isRest</span><span class="p">:</span>
                                <span class="n">rest_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s1">&#39;rest&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                                                         <span class="s1">&#39;dur&#39;</span><span class="p">:</span> <span class="n">duration2MEI</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">type</span><span class="p">],</span> <span class="s1">&#39;dots&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">dots</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
                            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;isChord&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">isChord</span><span class="p">:</span>
                                <span class="n">chord_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s1">&#39;chord&#39;</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">note</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">notes</span><span class="p">:</span>
                                    <span class="n">addMEINote</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="n">chord_el</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;expressions&#39;</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">expressions</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;fermata&#39;</span><span class="p">:</span>
                                        <span class="n">ferm_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">meas_el</span><span class="p">,</span> <span class="s1">&#39;fermata&#39;</span><span class="p">,</span>
                                                                <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;startid&#39;</span><span class="p">:</span> <span class="n">parent</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;xml:id&#39;</span><span class="p">)})</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;getSpannerSites&#39;</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">spanner</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">getSpannerSites</span><span class="p">():</span>
                                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spanner</span><span class="p">,</span> <span class="n">m21</span><span class="o">.</span><span class="n">spanner</span><span class="o">.</span><span class="n">Slur</span><span class="p">)</span> <span class="ow">and</span> <span class="n">el</span> <span class="o">==</span> <span class="n">spanner</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                        <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">meas_el</span><span class="p">,</span> <span class="s1">&#39;slur&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span>
                                                                        <span class="s1">&#39;startid&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;endid&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">spanner</span><span class="o">.</span><span class="n">getLast</span><span class="p">()</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="s1">&#39;beams&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beamsList</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beamsList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
                                <span class="n">parent</span> <span class="o">=</span> <span class="n">layer_el</span>
                                <span class="k">continue</span>

                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">m21</span><span class="o">.</span><span class="n">clef</span><span class="o">.</span><span class="n">Clef</span><span class="p">):</span>
                                <span class="n">clef_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s1">&#39;clef&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span>
                                    <span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">el</span><span class="o">.</span><span class="n">sign</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">})</span>
                            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">m21</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">TimeSignature</span><span class="p">):</span>
                                <span class="n">attrs_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s1">&#39;attributes&#39;</span><span class="p">,</span> <span class="p">{</span>
                                                         <span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
                                <span class="n">tsig_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                                    <span class="n">attrs_el</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
                                <span class="n">numerator_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">tsig_el</span><span class="p">,</span> <span class="s1">&#39;beats&#39;</span><span class="p">)</span>
                                <span class="n">numerator_el</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="o">.</span><span class="n">numerator</span><span class="si">}</span><span class="s1">&#39;</span>
                                <span class="n">denominator_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                                    <span class="n">tsig_el</span><span class="p">,</span> <span class="s1">&#39;beatType&#39;</span><span class="p">)</span>
                                <span class="n">denominator_el</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="o">.</span><span class="n">denominator</span><span class="si">}</span><span class="s1">&#39;</span>
                            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">m21</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">KeySignature</span><span class="p">):</span>
                                <span class="n">score_def_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span>
                                    <span class="s1">&#39;scoreDef&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
                                <span class="n">key_sig_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">score_def_el</span><span class="p">,</span> <span class="s1">&#39;keySig&#39;</span><span class="p">,</span> <span class="p">{</span>
                                                           <span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">)})</span>
                                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">sharps</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">key_sig_el</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;sig&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="o">.</span><span class="n">sharps</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">key_sig_el</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;sig&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">sharps</span><span class="p">)</span><span class="si">}</span><span class="s1">f&#39;</span><span class="p">)</span>
                                <span class="n">section</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">section</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">score_def_el</span><span class="p">)</span>

            <span class="n">indentMEI</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">indentation</span><span class="p">)</span>
            <span class="n">convert_attribs_to_str</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_meiTree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dfs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># add analysis data</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_analyses</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">measure</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.//measure&#39;</span><span class="p">):</span>
                    <span class="n">measure_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">measure</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">and</span> <span class="n">measure_number</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">stop</span> <span class="ow">and</span> <span class="n">measure_number</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">):</span>
                        <span class="n">measure</span><span class="o">.</span><span class="n">getparent</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">measure</span><span class="p">)</span>
            <span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parts</span><span class="p">(</span><span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextualize</span><span class="p">(</span>
                    <span class="n">df</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">measures</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">beats</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">columns</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)):</span>   <span class="c1"># trim _df to start and stop</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="n">_df</span> <span class="o">=</span> <span class="n">_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">:]]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;here&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">start</span><span class="p">:</span>
                        <span class="n">_df</span> <span class="o">=</span> <span class="n">_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:,</span> <span class="p">:]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_df</span> <span class="o">=</span> <span class="n">_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="n">dfstack</span> <span class="o">=</span> <span class="n">_df</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">future_stack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">measure</span> <span class="ow">in</span> <span class="n">dfstack</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                    <span class="n">meas_el</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;.//measure[@n=&quot;</span><span class="si">{</span><span class="n">measure</span><span class="si">}</span><span class="s1">&quot;]&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">meas_el</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">ndx</span> <span class="ow">in</span> <span class="n">dfstack</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ndx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">measure</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">ndx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">measure</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">dfstack</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span>
                        <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xml:id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">idGen</span><span class="p">),</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">tag</span><span class="p">,</span> <span class="s1">&#39;tstamp&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ndx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;staff&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ndx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;layer&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ndx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">}</span>
                        <span class="k">if</span> <span class="n">ndx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ii</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;place&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;below&#39;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;place&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;above&#39;</span>
                        <span class="n">analysis_el</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span>
                            <span class="n">meas_el</span><span class="p">,</span> <span class="n">analysis_tag</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
                        <span class="n">analysis_el</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">newRoot</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
            <span class="n">indentMEI</span><span class="p">(</span><span class="n">newRoot</span><span class="p">,</span> <span class="n">indentation</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">newRoot</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">file_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.mei&#39;</span><span class="p">):</span>
                <span class="n">file_name</span> <span class="o">+=</span> <span class="s1">&#39;.xml&#39;</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.mei.xml&#39;</span><span class="p">):</span>
                <span class="n">file_name</span> <span class="o">+=</span> <span class="s1">&#39;.mei.xml&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;./</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">meiDeclaration</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;unicode&#39;</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, AMPACT Research Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>